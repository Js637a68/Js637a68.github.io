<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>xv6 | Jerold‘s PNote</title><meta name="author" content="Jerold"><meta name="copyright" content="Jerold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="book-riscv操作系统接口操作系统管理和抽象硬件，使得程序共享硬件、共享数据 内核使用cpu提供的硬件保护机制实现保护模式 文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。我们将输入和输出称为 I&#x2F;O fork和exec分开使得可以对子进程IO重定向 如果两个文件描述符是通过一系列fork和dup调用从同一个原始文件描述符派生出来的，那么它们共享一个偏移">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6">
<meta property="og:url" content="http://example.com/%E9%A1%B9%E7%9B%AE/xv6/index.html">
<meta property="og:site_name" content="Jerold‘s PNote">
<meta property="og:description" content="book-riscv操作系统接口操作系统管理和抽象硬件，使得程序共享硬件、共享数据 内核使用cpu提供的硬件保护机制实现保护模式 文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。我们将输入和输出称为 I&#x2F;O fork和exec分开使得可以对子进程IO重定向 如果两个文件描述符是通过一系列fork和dup调用从同一个原始文件描述符派生出来的，那么它们共享一个偏移">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/17.jpg">
<meta property="article:published_time" content="2024-11-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-30T16:00:00.000Z">
<meta property="article:author" content="Jerold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/17.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/%E9%A1%B9%E7%9B%AE/xv6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'xv6',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/17.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jerold‘s PNote</span></a><a class="nav-page-title" href="/"><span class="site-name">xv6</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">xv6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-30T16:00:00.000Z" title="发表于 2024-12-01 2024-12-01T00:00:00+08:00">2024-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-30T16:00:00.000Z" title="更新于 2024-12-01 2024-12-01T00:00:00+08:00">2024-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="book-riscv"><a href="#book-riscv" class="headerlink" title="book-riscv"></a>book-riscv</h1><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><p>操作系统管理和抽象硬件，使得程序共享硬件、共享数据</p>
<p>内核使用cpu提供的硬件保护机制实现保护模式</p>
<p>文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。我们将输入和输出称为 I&#x2F;O</p>
<p>fork和exec分开使得可以对子进程IO重定向</p>
<p>如果两个文件描述符是通过一系列<code>fork</code>和<code>dup</code>调用从同一个原始文件描述符派生出来的，那么它们共享一个偏移量；</p>
<p>父子进程各自的文件描述符表条目指向同一个文件表项</p>
<p><code>2&gt;&amp;1</code>使得错误输出重定向到文件名描述符1，如果不加<code>&amp;</code>表示文件1</p>
<h2 id="操作系统架构"><a href="#操作系统架构" class="headerlink" title="操作系统架构"></a>操作系统架构</h2><p>操作系统要满足复用，隔离和交互</p>
<p>为实现隔离，将资源抽象为服务；Unix在进程之间透明地切换硬件处理器，根据需要保存和恢复寄存器状态；文件描述符简化了交互，内核为流水线失败进程生成eof</p>
<p>RISC-V三种指令模式：机器模式(Machine Mode)、用户模式(User Mode)和管理模式(Supervisor Mode)</p>
<p>RISC-V提供ecall指定内核控制转换到管理模式的入口的，sret返回用户空间</p>
<p>抽象进程包括用户&#x2F;管理模式标志，地址空间，线程时间切片</p>
<p>RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位，因此<code>MAXVA=0x3fffffffff</code>，在地址空间的顶部，xv6为<code>trampoline</code>（用于在用户和内核之间切换）和映射进程切换到内核的<code>trapframe</code>分别保留了一个页面</p>
<p>线程的大部分状态存储在线程栈区，进程包含用户栈和内核栈，即使用户栈被破坏，内核栈依然可以正常运行</p>
<p>加载程序将xv6内核加载到内存0x8000000，下面地址存放IO设备，cpu从_entry开始运行，_entry指令设置栈区，将stack0+4096加载到sp寄存器，运行start.c</p>
<p>start将mstatus改为管理模式，将main函数地址写入寄存器mepc，返回地址改为main，向页表寄存器satp写入0</p>
<p><strong>4.3、4.4系统调用</strong></p>
<p>a0，a1存放参数，a7存放系统调用号，ecall指令trap内核，执行uservec、usertrap、syscall，syscall存储系统调用号p-&gt;trapframe-&gt;a7，索引到syscalls数组，获得函数指针指向sys_exec接口，将返回值记录a0</p>
<p>fetchstr、copyinstr、walkaddr实现安全将数据传输到用户地址和获取用户地址的数据，walk检查虚拟地址是否用户地址，copyout将数据从内核复制到用户地址</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>映射相同的内存到不同的地址空间中（a trampoline page），并用一个未映射的页面保护内核和用户栈区</p>
<p>XV6基于Sv39 RISC-V运行，只使用64位虚拟地址低39位，一个页4k，因此有2^27个PTE，每个PTE前44位为PPN，后10位为flags，生成56位物理地址</p>
<p>在分级页表中，根页表地址存放在satp寄存器，每个cpu都拥有</p>
<p>页表分级结构大大节省内存，因为不用为中间页面目录分配页面</p>
<p>为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer (TLB) 中</p>
<p><img src="/./../../pic/xv6/image-20241203202616116.png" alt="image-20241203202616116"></p>
<p><strong>内核地址空间分配</strong></p>
<p>xv6维护一个页表单独描述内核空间，为每个进程维护一个页表描述用户空间，</p>
<p>内核中虚拟地址和物理地址直接映射</p>
<p>trampoline page：映射了两次到虚拟地址</p>
<p>Kstack page：留下一个guard page防止栈溢出</p>
<p><img src="/./../../pic/xv6/image-20241203203039183.png" alt="image-20241203203039183"></p>
<p><code>kvminit</code>首先分配一个pagetable_t内核页表，接着调用<code>kvmmap</code>直接映射图片显示那些地址，此时还未分页通过<code>kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)</code>看到是直接映射的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvmmap</code>就只是调用<code>mappages</code>设置每一个页表项</p>
<p>关键函数<code>walk</code>每次从虚拟地址获取9位来查找PTE，若PTE无效，如果设置alloc，walk将分配新页，返回最低一级PTE地址</p>
<p>这些代码依赖于直接映射的物理内存，也就是每次PTE可以提取下一级页表物理地址，无需转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line"><span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br></pre></td></tr></table></figure>

<p>接着<code>main</code>调用<code>kvminithart</code>将内核页表写入<strong>satp</strong>寄存器，每个RISC-V CPU将页表条目缓存在<strong>TLB</strong>，<code>sfence.vma</code>刷新当前CPU的TLB</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">sfence_vma();</span><br></pre></td></tr></table></figure>

<p>procinit为进程分配内核栈</p>
<p><strong>物理内存分配</strong></p>
<p>内核必须在运行时为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。xv6使用内核末尾到<code>PHYSTOP</code>之间的物理内存进行运行时分配。它一次分配和释放整个4096字节的页面。它使用链表的数据结构将空闲页面记录下来。分配时需要从链表中删除页面；释放时需要将释放的页面添加到链表中。</p>
<p><code>kinit</code>初始化空闲列表以保存从内核结束到<code>PHYSTOP</code>之间的每一页</p>
<p><code>freerange</code>调用<code>kfree</code>将每一页加入freelist链表，<code>kfree</code>将page每个字节填充1，即垃圾信息更快崩溃</p>
<p><strong>进程地址空间</strong></p>
<p>调用<code>kalloc</code>分配物理页面，将<strong>PTE</strong>添加到进程的页表中，指向新的物理页面</p>
<p><strong>exec</strong></p>
<blockquote>
<p>ELF文件格式：在计算机科学中，是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。ELF是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且它们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  ushort type;</span><br><span class="line">  ushort machine;</span><br><span class="line">  uint version;</span><br><span class="line">  uint64 entry;</span><br><span class="line">  uint64 phoff;</span><br><span class="line">  uint64 shoff;</span><br><span class="line">  uint flags;</span><br><span class="line">  ushort ehsize;</span><br><span class="line">  ushort phentsize;</span><br><span class="line">  ushort phnum;</span><br><span class="line">  ushort shentsize;</span><br><span class="line">  ushort shnum;</span><br><span class="line">  ushort shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program section header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">  uint32 type;</span><br><span class="line">  uint32 flags;</span><br><span class="line">  uint64 off;</span><br><span class="line">  uint64 vaddr;</span><br><span class="line">  uint64 paddr;</span><br><span class="line">  uint64 filesz;</span><br><span class="line">  uint64 memsz;</span><br><span class="line">  uint64 align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>exec</code>调用<code>proc_pagetable</code>函数分配一个新页表，初始化用户栈，在用户栈下面放一个<strong>guard page</strong>防止溢出；新映像若无效，跳到<strong>bad</strong>标签，释放旧映像前等待系统调用得到返回值；<strong>ELF</strong>文件地址可能故意引用内核，因此必须检查地址</p>
<h2 id="trap-and-syscall"><a href="#trap-and-syscall" class="headerlink" title="trap and syscall"></a>trap and syscall</h2><p>三种情况导致trap：</p>
<ol>
<li>系统调用，ecall</li>
<li>异常</li>
<li>设备中断</li>
</ol>
<p>处理trap四个阶段：</p>
<p> RISC-V CPU采取的硬件操作、为内核C代码执行而准备的汇编程序集“向量”、决定如何处理陷阱的C陷阱处理程序以及系统调用或设备驱动程序服务例程</p>
<p>内核通过写入寄存器来告诉CPU如何处理trap</p>
<ul>
<li><code>stvec</code>：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱。</li>
<li><code>sepc</code>：当发生陷阱时，RISC-V会在这里保存程序计数器<code>pc</code>（因为<code>pc</code>会被<code>stvec</code>覆盖）。<code>sret</code>（从陷阱返回）指令会将<code>sepc</code>复制到<code>pc</code>。内核可以写入<code>sepc</code>来控制<code>sret</code>的去向。</li>
<li><code>scause</code>： RISC-V在这里放置一个描述陷阱原因的数字。</li>
<li><code>sscratch</code>：保存指向<code>trapframe</code>地址，一开始就会用到</li>
<li><code>sstatus</code>：其中的<strong>SIE</strong>位控制设备中断是否启用。如果内核清空<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核重新设置<strong>SIE</strong>。<strong>SPP</strong>位指示陷阱是来自用户模式还是管理模式，并控制<code>sret</code>返回的模式。</li>
<li><code>fp</code>：指向栈顶</li>
</ul>
<p>在RV32和RV64中long和指针都与整数寄存器一样宽，32和64</p>
<p>七个整数寄存器t0-t6和十二个浮点寄存器ft0-ft11是临时寄存器，它们在调用之间是易失的，如果稍后使用，必须由调用者保存。十二个整数寄存器s0-s11和十二个浮点寄存器fs0-fs11在调用之间被保留，如果使用，必须由被调用者保存。</p>
<p><img src="/./../../pic/xv6/image-20241205200446821.png" alt="image-20241205200446821"></p>
<p>当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：</p>
<ol>
<li>如果陷阱是设备中断，并且状态<strong>SIE</strong>位被清空，则不执行以下任何操作。</li>
<li>清除<strong>SIE</strong>以禁用中断。</li>
<li>将<code>pc</code>复制到<code>sepc</code>。</li>
<li>将当前模式（用户或管理）保存在状态的<strong>SPP</strong>位中。</li>
<li>设置<code>scause</code>以反映产生陷阱的原因。</li>
<li>将模式设置为管理模式。</li>
<li>将<code>stvec</code>复制到<code>pc</code>。</li>
<li>在新的<code>pc</code>上开始执行。</li>
</ol>
<blockquote>
<p>使用专门的<code>stvev</code>寄存器获内核指定的指令地址是必要的，因为CPU不会切换内核页表，不会切换内核栈，不会保存除pc之外寄存器，因此当切换到管理模式而没有切换PC，内核则会访问到用户指令，例如用户程序修改<code>satp</code>寄存器使其指向一个允许访问所有物理内存的页表</p>
</blockquote>
<h3 id="陷入trap机制："><a href="#陷入trap机制：" class="headerlink" title="陷入trap机制："></a>陷入trap机制：</h3><p>当用户产生trap，跳转到<code>stvec</code>指定地址执行<code>uservec</code>，然后<code>usertrap</code>；返回时先<code>usertrapret</code>，然后<code>userret</code></p>
<p><strong>一个巧妙的设计</strong>是使用<code>trampoline page</code>保存<code>uservec</code>，这样在用户空间的内核空间就有相同的映射，当切换内核表时内核也可以正常工作</p>
<p>在trampoline.S中，<code>.section trampsec</code>指定代码在trampsec的section中，<code>uservec</code>汇编代码首先csrrw切换a0和sscratch寄存器的值，这样a0指向了trapframe，通过a0+偏移量就可以保存32个寄存器的值了，最后设置sp、tp、t0、t1寄存器就跳转到<code>usertrap</code></p>
<p>在<code>usertrap</code>：确定trap原因是上面三种情况的哪一种，，更改<code>stvec</code>指向<code>kernelvec</code>，将sepc写入p-&gt;trapframe-&gt;epc，因为当陷阱由定时器中断触发的话，<strong>yield</strong>切换到另一个进程的内核线程，而该进程可能返回到用户空间，在该过程中它将修改<code>sepc</code></p>
<p>RISC-V使用<code>scause</code>寄存器来指示触发缺页异常的原因，而<code>stval</code>寄存器则包含了无法被转换的地址。</p>
<p><code>usertrapret</code>：调用<code>userret</code>切换用户页表，a0和a1指向<code>TRAPFRAME</code>和用户页表</p>
<p><code>userret</code>：恢复保存的寄存器值，csrrw，<code>sret</code>返回用户空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">	#</span><br><span class="line">        # code to switch between user and kernel space.</span><br><span class="line">        #</span><br><span class="line">        # this code is mapped at the same virtual address</span><br><span class="line">        # (TRAMPOLINE) in user and kernel space so that</span><br><span class="line">        # it continues to work when it switches page tables.</span><br><span class="line">	#</span><br><span class="line">	# kernel.ld causes this to be aligned</span><br><span class="line">        # to a page boundary.</span><br><span class="line">        #</span><br><span class="line">	.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        # trap.c sets stvec to point here, so</span><br><span class="line">        # traps from user space start here,</span><br><span class="line">        # in supervisor mode, but with a</span><br><span class="line">        # user page table.</span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process&#x27;s p-&gt;trapframe is</span><br><span class="line">        # mapped into user space, at TRAPFRAME.</span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">	# swap a0 and sscratch</span><br><span class="line">        # so that a0 is TRAPFRAME</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # save the user registers in TRAPFRAME</span><br><span class="line">        sd ra, 40(a0)</span><br><span class="line">        sd sp, 48(a0)</span><br><span class="line">        sd gp, 56(a0)</span><br><span class="line">        sd tp, 64(a0)</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        jr t0</span><br><span class="line"></span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)</span><br><span class="line">        # switch from kernel to user.</span><br><span class="line">        # usertrapret() calls here.</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        sret</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Page-fault"><a href="#Page-fault" class="headerlink" title="Page-fault"></a>Page-fault</h3><p>RISC-V架构区分了三种类型的缺页异常：</p>
<ul>
<li>加载缺页（load page faults）：当加载指令无法将其虚拟地址转换为物理地址时触发。</li>
<li>存储缺页（store page faults）：当存储指令无法将其虚拟地址转换为物理地址时触发。</li>
<li>指令缺页（instruction page faults）：当程序计数器中的地址无法转换为物理地址时触发。</li>
</ul>
<p><strong>COW好处：</strong></p>
<ul>
<li>在<code>fork</code>中简单的<code>uvmcopy</code>分配物理内存和复制页表，真实实现了<code>COW fork</code>，最初共享只读(~PTE_W)，当写入时引发页面异常错误，然后内核复制了包含错误地址的页面。</li>
</ul>
<blockquote>
<p>这里同时在父子进程只拷贝缺少的页面，因此fork后立即exec，只会拷贝少量页面，高效</p>
</blockquote>
<ul>
<li>lazy allocation：<code>sbrk</code>时内核记录大小增加，写时分配</li>
<li>磁盘分页：内核只需为一个庞大的程序分配需要用到的物理内存，将PTEs标记无效，根据内存表现实现分页到磁盘</li>
<li>自动扩展栈空间和内存映射文件</li>
</ul>
<h2 id="中断和设备驱动"><a href="#中断和设备驱动" class="headerlink" title="中断和设备驱动"></a>中断和设备驱动</h2><p>许多设备驱动程序在两种环境中执行代码：上半部分在进程的内核线程中运行，下半部分在中断时执行。上半部分通过<strong>系统调用</strong>进行调用，动程序的<strong>中断处理程序</strong>充当下半部分</p>
<p><strong>控制台输入：</strong></p>
<p>Xv6的<code>main</code>函数调用<code>consoleinit</code>来初始化UART硬件。该代码配置UART：UART对接收到的每个字节的输入生成一个接收中断，对发送完的每个字节的输出生成一个发送完成中断</p>
<p>shell通过init.c打开的文件描述符读取输入，对<code>read</code>的调用最终到达<code>consoleread</code> ，可以看到consoleread的sleep导致read阻塞</p>
<p>用户输入字符后UART硬件要求RISC-V发出一个中断，调用<code>devintr</code>，根据<code>scause</code>寄存器的值判断外设。通过PLIC获取设备中断，例如<code>UART</code>调用<code>uartintr</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">devintr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 scause = <span class="built_in">r_scause</span>();</span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000L</span>) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="type">int</span> irq = <span class="built_in">plic_claim</span>();</span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      <span class="built_in">uartintr</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      <span class="built_in">virtio_disk_intr</span>();</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uartintr</code>从UART硬件读取所有等待输入的字符，并将它们交给<code>consoleintr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">uartgetc</span>();</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">consoleintr</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>consoleintr</code>的工作是在<strong>cons.buf</strong>中积累输入字符，直到一整行到达然后唤醒<code>consoleread</code>，C(‘D’)表示文件结束或者缓冲区满，更新e，并且更新w这样<code>consoleread</code>知道新的输入可用，唤醒所有因cons.r而睡眠的进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cons.buf[cons.e++ % INPUT_BUF] = c;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="built_in">C</span>(<span class="string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;</span><br><span class="line"><span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line"><span class="comment">// has arrived.</span></span><br><span class="line">cons.w = cons.e;</span><br><span class="line"><span class="built_in">wakeup</span>(&amp;cons.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>consoleread</code>从sleep醒来后将cons.buf缓存区每个字符发送到用户空间，直接一整行或者又进入sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">myproc</span>()-&gt;killed)&#123;</span><br><span class="line">        <span class="built_in">release</span>(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">sleep</span>(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="built_in">C</span>(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">either_copyout</span>(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>控制台输出</strong>：</p>
<p><code>write</code>最终到达<code>uartputc</code>，<code>uartputc</code>将字符添加到缓存区<strong>uart_tx_buf</strong>，满时等待，调用<code>uartstart</code>启动设备传输并写入<strong>THR</strong>寄存器一个字节，<strong>UART</strong>传输该字节生成中断调用<code>uartintr</code>，其余的字节会在<code>uartintr</code>触发的传输完成中断到达时，由<code>uartstart</code>调用发送。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>bcache.lock</code></td>
<td>保护块缓冲区缓存项（block buffer cache entries）的分配</td>
</tr>
<tr>
<td><code>cons.lock</code></td>
<td>串行化对控制台硬件的访问，避免混合输出</td>
</tr>
<tr>
<td><code>ftable.lock</code></td>
<td>串行化文件表中文件结构体的分配</td>
</tr>
<tr>
<td><code>icache.lock</code></td>
<td>保护索引结点缓存项（inode cache entries）的分配</td>
</tr>
<tr>
<td><code>vdisk_lock</code></td>
<td>串行化对磁盘硬件和DMA描述符队列的访问</td>
</tr>
<tr>
<td><code>kmem.lock</code></td>
<td>串行化内存分配</td>
</tr>
<tr>
<td><code>log.lock</code></td>
<td>串行化事务日志操作</td>
</tr>
<tr>
<td>管道的<code>pi-&gt;lock</code></td>
<td>串行化每个管道的操作</td>
</tr>
<tr>
<td><code>pid_lock</code></td>
<td>串行化next_pid的增量</td>
</tr>
<tr>
<td>进程的<code>p-&gt;lock</code></td>
<td>串行化进程状态的改变</td>
</tr>
<tr>
<td><code>tickslock</code></td>
<td>串行化时钟计数操作</td>
</tr>
<tr>
<td>索引结点的 <code>ip-&gt;lock</code></td>
<td>串行化索引结点及其内容的操作</td>
</tr>
<tr>
<td>缓冲区的<code>b-&gt;lock</code></td>
<td>串行化每个块缓冲区的操作</td>
</tr>
</tbody></table>
<p><strong>竞态条件</strong>是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。尽管正确使用锁可以改正不正确的代码，但锁使得CPU串行化限制了性能</p>
<p><strong>自旋锁：</strong></p>
<p>在RISC-V上，原子指令是<code>amoswap r, a</code>。<code>amoswap</code>读取内存地址<code>a</code>处的值，将寄存器<code>r</code>的内容写入该地址，并将其读取的值放入<code>r</code>中。</p>
<p><code>acquire</code>使用执行原子赋值的C库函数<code>__sync_lock_test_and_set</code>；<code>release</code>使用执行原子赋值的C库函数<code>__sync_lock_release</code></p>
<p><strong>睡眠锁</strong></p>
<p>睡眠锁有一个被自旋锁保护的锁定字段，<code>acquiresleep</code>对<code>sleep</code>的调用原子地让出CPU并释放自旋锁</p>
<p>当CPU获取任何锁时，xv6总是禁用该CPU上的中断。</p>
<p><code>acquire</code>调用<code>push_off</code> 并且<code>release</code>调用<code>pop_off</code>来跟踪当前CPU上锁的嵌套级别。当计数达到零时，<code>pop_off</code>恢复最外层临界区域开始时存在的中断使能状态。<code>intr_off</code>和<code>intr_on</code>函数执行RISC-V指令分别用来禁用和启用中断。</p>
<p>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为<strong>内存模型</strong>（memory model）。xv6在<code>acquire</code>和<code>release</code>中都使用了<code>__sync_synchronize()</code>。<code>__sync_synchronize()</code>是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序<code>load</code>或<code>store</code>指令</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p><strong>多路复用：</strong></p>
<ol>
<li>当进程等待设备或管道I&#x2F;O完成，或等待子进程退出，或在<code>sleep</code>系统调用中等待时，xv6使用睡眠（sleep）和唤醒（wakeup）机制切换。</li>
<li>xv6周期性地强制切换以处理长时间计算而不睡眠的进程。</li>
</ol>
<p><img src="/./../../pic/xv6/image-20241224214601491.png" alt="image-20241224214601491"></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>调用<code>swtch</code>来保存自己的上下文并返回到调度程序的上下文。接受两个参数：<code>struct context *old</code>和<code>struct context *new</code>。</p>
<p>中断结束时的一种可能性是<code>usertrap</code>调用了<code>yield</code>。依次地：<code>Yield</code>调用<code>sched</code>，<code>sched</code>调用<code>swtch</code>将当前上下文保存在<code>p-&gt;context</code>中，并切换到先前保存在<code>cpu-&gt;scheduler</code>中的调度程序上下文。<code>swtch.S</code>中只保存s0-s11，即<strong>callee-saved register</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">yield</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="built_in">sched</span>();</span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sched</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holding</span>(&amp;p-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">intr_get</span>())</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = <span class="built_in">mycpu</span>()-&gt;intena;</span><br><span class="line">  <span class="built_in">swtch</span>(&amp;p-&gt;context, &amp;<span class="built_in">mycpu</span>()-&gt;context);</span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="built_in">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      <span class="built_in">intr_on</span>();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>在RISCV架构中，caller-saved寄存器在进去函数前由调用方被保存，在调用函数中，callee-saved寄存器如果需要修改则由被调用方修改和函数返回时恢复；<strong>swtch</strong>汇编保存s0-s11是callee-saved寄存器，caller-saved寄存器在调用swtch前被保存在栈上了，这里进程上下文切换可用简单的看似函数调用，因此需要手动保存s0-s11，ra保存swtch下条指令地址，因此不需要保存pc；<code>Swtch</code>在调度程序的栈上返回，就像是<code>scheduler</code>的<code>swtch</code>返回一样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>



<h3 id="sleep和wakeup"><a href="#sleep和wakeup" class="headerlink" title="sleep和wakeup"></a>sleep和wakeup</h3><p>xv6睡眠和唤醒被用作条件同步机制</p>
<p><code>P</code>持有<code>s-&gt;lock</code>的事实阻止<code>V</code>在<code>P</code>检查<code>s-&gt;count</code>和调用<code>sleep</code>之间试图唤醒它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">V</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(s);</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="keyword">struct</span> semaphore* s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">sleep</span>(s, &amp;s-&gt;lock);  <span class="comment">// !pay attention</span></span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">release</span>(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong><code>sleep</code>函数</strong>：<ul>
<li><code>sleep</code>函数使得当前进程进入<code>SLEEPING</code>状态，并调用<code>sched</code>函数释放CPU控制权。</li>
<li><code>sleep</code>函数需要传入一个等待通道（<code>chan</code>），进程将在该通道上等待被唤醒。</li>
<li>在调用<code>sleep</code>之前，进程必须持有一个互斥锁（<code>lk</code>），以确保在进入睡眠状态之前没有其他进程能够调用<code>wakeup</code>。</li>
<li><code>sleep</code>函数会获取进程自身的锁<code>p-&gt;lock</code>，释放传入的锁<code>lk</code>，以保护进程状态的修改。</li>
<li>进程在<code>sleep</code>之后，将不会被调度器再次选择执行，直到它被<code>wakeup</code>唤醒。</li>
</ul>
</li>
<li><strong><code>wakeup</code>函数</strong>：<ul>
<li><code>wakeup</code>函数用于唤醒所有在指定通道上睡眠的进程。</li>
<li>它遍历进程表，对于每个在<code>SLEEPING</code>状态且等待指定通道的进程，将其状态更改为<code>RUNNABLE</code>。</li>
<li><code>wakeup</code>在修改进程状态时需要获取进程锁<code>p-&gt;lock</code>，以确保状态的一致性。</li>
</ul>
</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>xv6文件系统实现分为七层</p>
<table>
<thead>
<tr>
<th>文件描述符（File descriptor）</th>
<th>文件描述符层使用文件系统接口抽象了许多Unix资源（例如，管道、设备、文件等）</th>
</tr>
</thead>
<tbody><tr>
<td>路径名（Pathname）</td>
<td>路径名层提供了分层路径名，如***&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c***，并通过递归查找来解析它们</td>
</tr>
<tr>
<td>目录（Directory）</td>
<td>目录层将每个目录实现为一种特殊的索引结点，其内容是一系列目录项，每个目录项包含一个文件名和索引号</td>
</tr>
<tr>
<td>索引结点（Inode）</td>
<td>每个文件表示为一个索引结点</td>
</tr>
<tr>
<td>日志（Logging）</td>
<td>日志记录层允许更高层在一次事务（transaction）中将更新包装到多个块，并确保在遇到崩溃时自动更新这些块</td>
</tr>
<tr>
<td>缓冲区高速缓存（Buffer cache）</td>
<td>缓冲区高速缓存层缓存磁盘块并同步对它们的访问</td>
</tr>
<tr>
<td>磁盘（Disk）</td>
<td>磁盘层读取和写入virtio硬盘上的块</td>
</tr>
</tbody></table>
<blockquote>
<p>&#x2F;&#x2F; File system implementation.  Five layers:</p>
<p>&#x2F;&#x2F;  + Blocks: allocator for raw disk blocks.</p>
<p>&#x2F;&#x2F;  + Log: crash recovery for multi-step updates.</p>
<p>&#x2F;&#x2F;  + Files: inode allocator, reading, writing, metadata.</p>
<p>&#x2F;&#x2F;  + Directories: inode with special contents (list of other inodes!)</p>
<p>&#x2F;&#x2F;  + Names: paths like &#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c for convenient naming.</p>
</blockquote>
<h3 id="Buffer-cache层"><a href="#Buffer-cache层" class="headerlink" title="Buffer cache层"></a>Buffer cache层</h3><p><code>bread</code>获取一个<em>buf</em>，其中包含一个可以在内存中读取或修改的块的副本；<code>bwrite</code>；将修改后的缓冲区写入磁盘上的相应块。</p>
<p>Buffer cache每个缓冲区使用一个睡眠锁，<code>bread</code>返回一个上锁的缓冲区，<code>brelse</code>释放该锁；使用LRU置换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> buf[NBUF];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> head;</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p><code>binit</code>使用静态buf[NBUF]初始化，并通过head循环链表的形式进行访问，以此来LRU置换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bcache.head.prev = &amp;bcache.head;</span><br><span class="line">bcache.head.next = &amp;bcache.head;</span><br><span class="line"><span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">b-&gt;next = bcache.head.next;</span><br><span class="line">b-&gt;prev = &amp;bcache.head;</span><br><span class="line"><span class="built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">bcache.head.next-&gt;prev = b;</span><br><span class="line">bcache.head.next = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bread(uint dev, uint blockno)</code>调用<code>bget(uint dev, uint blockno)</code>循环链表获取缓存区，若没有匹配，则从pre往前遍历，符合LRU，修改<strong>valid字段</strong>为0并返回一个buf来进行磁盘读块<code>  virtio_disk_rw(b, 0);</code></p>
<blockquote>
<p>struct buf中的sleeplock保证了同时对同一个buf进行bread只有一个进程获得能得对buf的引用</p>
</blockquote>
<p><code>brelse(struct buf *b)</code>释放缓存区并移至链表最前面，一遍bget使用从后往前扫描最近最少使用</p>
<h3 id="日志层"><a href="#日志层" class="headerlink" title="日志层"></a>日志层</h3><p>xv6会在磁盘上的<em>log</em>（日志）中放置它希望进行的所有磁盘写入的描述。一旦系统调用记录了它的所有写入操作，它就会向磁盘写入一条特殊的<em>commit</em>（提交）记录，表明日志包含一个完整的操作；写入磁盘后再擦除磁盘日志；若未提交则忽略，若已提交则重复操作，在任何一种情况下，日志都会使操作在崩溃时成为原子操作</p>
<ol>
<li><p>日志驻留在超级块中指定的已知固定位置。</p>
</li>
<li><p>它由一个头块（header block）和一系列更新块的副本（logged block）组成。</p>
</li>
<li><p>n为记录块数量，为0表示没有事务，非0表示日志包含一个完整的已提交事务</p>
</li>
<li><p>在事务提交（commit）时Xv6才向头块写入数据，在将logged blocks复制到文件系统后将计数设置为零</p>
</li>
<li><p>日志系统可以将多个系统调用的写操作累积到一个事务中，这称为组提交（group commit）；组提交减少了磁盘操作次数，因为它将提交的固定成本分摊到多个操作上。</p>
</li>
<li><p>组提交还可以在同一个磁盘旋转期间将多个并发写操作交给磁盘系统，可能允许磁盘在单次旋转中全部写入</p>
</li>
<li><p>写操作（write）和删除操作（unlink）可能写入许多块，因此xv6的写系统调用将大的写操作分解为适合日志空间的多个较小的写操作。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">logheader</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">log</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">logheader</span> lh;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>典型使用文件系统调用，以下表示一个事务开始和结束</p>
<ol>
<li><p><code>begin_op()</code>检查<code>log.committing</code>和<code>log.lh.n + (log.outstanding+1)*MAXOPBLOCKS &gt; LOGSIZE</code>当没有提交进行或者空间足够时，<code>log.outstanding += 1;</code>预定空间；否则sleep</p>
</li>
<li><p><code>end_op()</code>减少系统调用次数，非0时wakeup唤醒begin_op此时有空间，为0时进行提交，<code>commit()</code>分为四个阶段：</p>
<ol>
<li><code>write_log()</code>写入日志；<code>log.ln.n</code>和<code>log.ln.block</code>记录系统调用的块(cache block)，复制到日志槽(log block)中（即<code>long.start+1</code>磁盘块开始）<code>bread(log.dev, log.start+tail+1)</code></li>
<li><code>write_head()</code>写入头块，即<code>long.start</code>磁盘块来存储头块：<code>(struct logheader *) bread(log.dev, log.start);</code></li>
<li><code>install_trans</code>写入文件系统，跟<code>write_log()</code>相反</li>
<li><code>log.lh.n = 0;</code>计数清零，再次调用<code>write_head()</code></li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<h3 id="inode层"><a href="#inode层" class="headerlink" title="inode层"></a>inode层</h3><p>磁盘上的inode由<code>struct dinode</code>定义，<code>type</code>为零表示磁盘inode是空闲的。字段<code>nlink</code>统计引用此inode的目录项的数量</p>
<p><code>struct inode</code>是磁盘dinode的内存副本，只有当有C指针引用某个inode时，内核才会在内存中存储该inode。由<code>ref</code>字段统计引用次数，可以来自文件描述符、当前工作目录和如<code>exec</code>的瞬态内核代码。</p>
<blockquote>
<p>provide a place for synchronizing access to inodes used by multiple processes.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>xv6中一个block size为1k，<code>balloc</code>通过外部循环读取每个bmap block，内部循环bmap位获取空闲块并调用<code>log_write()</code>将blockno即获取的空闲块号写入到日志头块中</p>
<blockquote>
<p>inode缓存是直写的，这意味着修改已缓存inode的代码必须立即使用<code>iupdate</code>将其写入磁盘。</p>
</blockquote>
<p><code>Ialloc</code>类似于<code>balloc</code>：一次只有一个进程可以保存对<code>bp</code>的引用</p>
<p><code>iget</code>返回inode的引用或者空槽</p>
<p><code>iput</code>减少引用，当最后一个引用并且没有目录项指向这个文件必须调用<code>itrunc</code>释放</p>
<blockquote>
<p>iput期间可能崩溃，这将导致文件将被标记为已在磁盘上分配，但没有目录项指向它。可用通过重启后扫描整个文件系统或记录在链表上进行释放，xv6没有解决，可能会面临磁盘空间不足的风险。</p>
</blockquote>
<p><code>itrunc</code>首先释放NDIRECT(12)个直接块，然后释放一个间接块(NINDIRECT)，<code>bfree</code>操作上是将bmap对应位置0</p>
<p><code>bmap</code>先获取直接块后再获取间接块，遇到0时分配块；<code>Bmap</code>使<code>readi</code>和<code>writei</code>很容易获取inode的数据。</p>
<p>这段代码很好的处理了偏移量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">    ip-&gt;size = off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">  <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">  <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目录层"><a href="#目录层" class="headerlink" title="目录层"></a>目录层</h3><p>数据是一系列目录条目(dirent)，</p>
<p><code>struct inode* dirlookup(struct inode *dp, char *name, uint *poff)</code>查找目录项并设置poff偏移量</p>
<p><code>int dirlink(struct inode *dp, char *name, uint inum)</code>写入目录项，若存在则iput并返回-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct dirent &#123;</span><br><span class="line">  ushort inum;</span><br><span class="line">  char name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="路径名层"><a href="#路径名层" class="headerlink" title="路径名层"></a>路径名层</h3><h2 id="文件系统可靠性："><a href="#文件系统可靠性：" class="headerlink" title="文件系统可靠性："></a>文件系统可靠性：</h2><ol>
<li>保持</li>
<li>可预测</li>
<li>原子性</li>
</ol>
<p>同步元数据—&gt;延迟有序写入(更新依赖问题)—&gt;软更新</p>
<h1 id="lab"><a href="#lab" class="headerlink" title="lab"></a>lab</h1><h2 id="lab1-util"><a href="#lab1-util" class="headerlink" title="lab1 util"></a>lab1 util</h2><p>sleep</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;sleep: argc != 2\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sleep</span>(t);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pingpong</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>],p2[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">pipe</span>(p1);</span><br><span class="line">    <span class="built_in">pipe</span>(p2);</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">read</span>(p1[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf)) &lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child failed read ping\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pid = <span class="built_in">getpid</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; received ping\n&quot;</span>, pid);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(p2[<span class="number">1</span>], <span class="string">&quot;o&quot;</span>, <span class="number">1</span>) &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;child  failed write pong\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p1[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(p2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(p1[<span class="number">1</span>], <span class="string">&quot;i&quot;</span>, <span class="number">1</span>) &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent failed write ping\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">read</span>(p2[<span class="number">0</span>], buf, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;parent failed read pong\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;%d&gt; received pong\n&quot;</span>, pid);</span><br><span class="line">    <span class="built_in">close</span>(p1[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(p2[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>primes</p>
<p>我这里只试到37就报错pipe失败了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> prime;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">read</span>(p[<span class="number">0</span>], &amp;prime, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(p1) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;primes: falied pipe\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(p1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p1[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(p[<span class="number">0</span>], &amp;num, <span class="number">4</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % prime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">write</span>(p1[<span class="number">1</span>], &amp;num, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;primes: failed, write\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(p1[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pipe</span>(p) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;primes: falied pipe\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(p[<span class="number">1</span>], &amp;i, <span class="number">4</span>) != <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;primes: falied write\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">wait</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>find</p>
<p>基本跟ls一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="keyword">if</span>((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(st.type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find dir file\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) ==<span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">memmove</span>(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(st.type == T_DIR)</span><br><span class="line">                    <span class="built_in">find</span>(buf, filename);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(st.type == T_FILE)</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name, filename) == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find argc not 3\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">find</span>(path, filename);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xargs</p>
<p>将标准输入转换为命令行参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xargs #等同于xargs echo</span><br><span class="line">echo -e &quot;a\tb\tc&quot;|xargs -d &quot;\t&quot; echo # 分隔符</span><br><span class="line">echo &#x27;abc&#x27;|xargs -p touch # 打印执行命令，询问；-t</span><br><span class="line">xargs -n 1 find -name # 每一项执行一次find -name</span><br><span class="line">cat foot.txt|xargs -I file sh -c &#x27;echo file; mkdir file&#x27; # 替换字符串</span><br></pre></td></tr></table></figure>

<p>这里的xargs从标准输入读取每行执行即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *new_argv[MAXARG], <span class="type">int</span> argc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>, buf+n, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1023</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(buf[n] == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(offset &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        new_argv[argc++] = buf + offset;</span><br><span class="line">        <span class="keyword">while</span>(buf[offset] != <span class="string">&#x27; &#x27;</span> &amp;&amp; offset &lt; n) offset++;</span><br><span class="line">        <span class="keyword">while</span>(buf[offset] == <span class="string">&#x27; &#x27;</span>) buf[offset++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_argv[argc] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: command(arg...)\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *command = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *new_argv[MAXARG];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        new_argv[i<span class="number">-1</span>] = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(argv[i])+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(new_argv[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(readline(new_argv, argc<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            exec(command, new_argv);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)</span><br><span class="line">        <span class="built_in">free</span>(new_argv[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab2-syscall"><a href="#lab2-syscall" class="headerlink" title="lab2 syscall"></a>lab2 syscall</h2><h3 id="system-call-tracing"><a href="#system-call-tracing" class="headerlink" title="system call tracing"></a>system call tracing</h3><p>打印系统调用通过在进程<code>struct proc</code>添加trace_mask掩码，每次调用<code>syscall</code>时位运算相与syscall number来打印</p>
<p>添加系统调用过程：在user.h添加<code>trace</code>系统调用接口，并在usys.pl存根，usys.pl脚本调用entry生成汇编代码，将系统调用号存到a7，调用ecall进入内核</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">my</span> <span class="variable">$name</span> = <span class="keyword">shift</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;.global <span class="variable">$name</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;<span class="subst">$&#123;name&#125;</span>:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; li a7, SYS_<span class="subst">$&#123;name&#125;</span>\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候内核并没有<code>sys_trace</code>，在syscall.h添加<code>#define SYS_trace  22</code>系统调用号，在syscall.c中添加声明<code>extern uint64 sys_trace(void);</code>和数组项<code>[SYS_trace]  sys_trace,</code></p>
<p>我在sysproc.c实现<code>sys_trace</code>函数，所有系统调用都没有参数，通过argint从a0-a7获取参数，统一参数的传递和提取(4.3，4.4有说明)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;trace_mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改<code>syscall</code>函数，并且在<code>fork()</code>将trace_mask传递子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *psys[] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">    <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">    <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    <span class="string">&quot;write&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">    <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">    <span class="string">&quot;close&quot;</span>,</span><br><span class="line">    <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; num) &amp; p-&gt;trace_mask)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, psys[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h3><p>依照上面步骤，依然在sysproc.c添加sysinfo系统调用，在kallo.c添加freekmem()，在proc.c添加nproc()，最后在defs.h添加函数声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = freekmem();</span><br><span class="line">  info.nproc = nproc();</span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">freekmem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 sum = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)</span><br><span class="line">  &#123;</span><br><span class="line">    sum++;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> sum * PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state!= UNUSED)</span><br><span class="line">      n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab3-pgtb"><a href="#lab3-pgtb" class="headerlink" title="lab3 pgtb"></a>lab3 pgtb</h2><h3 id="vmprint"><a href="#vmprint" class="headerlink" title="vmprint"></a>vmprint</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprintf</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp;(PTE_R|PTE_W|PTE_X))==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line">      <span class="type">pagetable_t</span> next = (<span class="type">pagetable_t</span>)PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">512</span>; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte1 = next[j];</span><br><span class="line">        <span class="keyword">if</span>((pte1 &amp; PTE_V) &amp;&amp; (pte1 &amp; (PTE_R|PTE_W|PTE_X))==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, j, pte1, PTE2PA(pte1));</span><br><span class="line">          <span class="type">pagetable_t</span> nnext = (<span class="type">pagetable_t</span>)PTE2PA(pte1);</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">512</span>; k++)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="type">pte_t</span> pte2 = nnext[k];</span><br><span class="line">            <span class="keyword">if</span>((pte2 &amp; PTE_V))&#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, k, pte2, PTE2PA(pte2));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">init: starting sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从图片3-4可以看到，这段地址是exec init的页表，exec为text和data段分配一个page也就是0，为stack分配一个page也就是2，而中间1是guarde page，程序在用户模式下访问会报错，最后510，511刚好符合trampoline和tramframe</p>
</blockquote>
<p><img src="/./../../pic/xv6/image-20241204114414385.png" alt="image-20241204114414385"></p>
<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><p>1、在<code>struct proc</code>加上内核页表字段<code>pagetable_t kpagetable</code></p>
<p>2、为一个新进程生成内核页表，并设置映射关系和写入satp寄存器，因此这三个函数跟操作内核页表实现一样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">prockptinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kptb = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kptb, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  prockptmap(kptb, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  prockptmap(kptb, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  prockptmap(kptb, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  prockptmap(kptb, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  prockptmap(kptb, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  prockptmap(kptb, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  prockptmap(kptb, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> kptb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prockptmap</span><span class="params">(<span class="type">pagetable_t</span> kpt, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpt, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinithart</span><span class="params">(<span class="type">pagetable_t</span> kpt)</span></span><br><span class="line">&#123;</span><br><span class="line">  w_satp(MAKE_SATP(kpt));</span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freeprockpt</span><span class="params">(<span class="type">pagetable_t</span> kpt)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = kpt[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freeprockpt((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      kpt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)kpt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、在<code>allocproc</code>每次进程创建时调用<code>prockptinit</code>生成内核页表，并将<code>procinit</code>函数功能迁移到<code>allocproc</code>中为分配内核栈和调用<code>prockptmap</code>设置映射关系</p>
<p>4、每当切换进程时同时切换进程内核页表，因此在<code>scheduler</code>函数调用<code>procinithart</code>切换和<code>kvminithart</code>切回</p>
<p>5、调用<code>freeproc</code>释放进程时释放内核页表，参考<code>freewalk</code></p>
<p>记录错误：</p>
<p>在<code>allocproc</code>分配内核栈先<code>p-&gt;context.sp = p-&gt;kstack + PGSIZE;</code>然后再分配导致一直卡住</p>
<p><code>kvmpa</code>内核栈虚拟地址转换物理地址没有修改成进程独自的内核页表</p>
<p><code>test sbrkfail: panic: prockptmap</code>映射关系设置错误，释放进程时没有解除内核栈映射调用<code>uvmunmap</code></p>
<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><p>一般情况在用户空间我们可以直接解引用srcva，而内核空间没有这个虚拟地址的映射，需要将其转换为物理地址</p>
<p>对比一下<code>copy_in</code>和<code>copyin_new</code>，需要将srcva转换为物理地址的page+偏移量，在这一个实验通过将用户页表映射复制到内核页表映射使得内核也可以直接访问srcva地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va0 = PGROUNDDOWN(srcva);</span><br><span class="line">pa0 = walkaddr(pagetable, va0);</span><br><span class="line">memmove(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memmove((<span class="type">void</span> *) dst, (<span class="type">void</span> *)srcva, len);</span><br></pre></td></tr></table></figure>

<p>copy函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">u2kcopy</span><span class="params">(<span class="type">pagetable_t</span> uptb, <span class="type">pagetable_t</span> kptb, uint64 va, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte, *pte1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(; va &lt; sz; va += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(uptb, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;u2kmap: walk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pte1 = walk(kptb, va, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;u2kmap: walk&quot;</span>);</span><br><span class="line">    *pte1 = *pte &amp; ~(PTE_U);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后给<code>fork</code>,<code>exec</code>,<code>growproc</code>调用<code>u2kcopy</code>，因为这些改变了pagetable，不要忘记给<code>userinit</code>复制映射关系，不然一直卡在启动界面</p>
<p>记录错误：</p>
<p>缺页错误，gdb找到调用<code>copyin_new</code>的上一个函数调用是<code>fork</code>发现<code>u2kcopy</code>复制映射到p而不是np</p>
<blockquote>
<p>(srcva &gt;&#x3D; p-&gt;sz || srcva+len &gt;&#x3D; p-&gt;sz || srcva+len &lt; srcva)第三个测试是为了防止溢出，当len特别大就有可能发生</p>
</blockquote>
<h2 id="lab4-trap"><a href="#lab4-trap" class="headerlink" title="lab4 trap"></a>lab4 trap</h2><h3 id="risc-v-assembly"><a href="#risc-v-assembly" class="headerlink" title="risc-v assembly"></a>risc-v assembly</h3><ol>
<li>哪些寄存器保存函数的参数？例如，在<code>main</code>对<code>printf</code>的调用中，哪个寄存器保存13？</li>
</ol>
<blockquote>
<p>a0-a7寄存器，a2保存13</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">24:	4635                	li	a2,13</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>main</code>的汇编代码中对函数<code>f</code>的调用在哪里？对<code>g</code>的调用在哪里(提示：编译器可能会将函数内联）</li>
</ol>
<blockquote>
<p>看到g和f的汇编一模一样，因为f直接调用g，print中并没有看到调用f，而是编译器优化看，将函数内联直接得到12</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br><span class="line">  </span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>printf</code>函数位于哪个地址？</li>
</ol>
<blockquote>
<p>  34:	650080e7          	jalr	1616(ra) # 680 <printf></p>
<p>  unsigned int i &#x3D; 0x00646c72;<br>  38:	006477b7          	lui	a5,0x647</p>
<p>…</p>
<p>0000000000000680 <printf>:</p>
</blockquote>
<ol start="4">
<li>在<code>main</code>中<code>printf</code>的<code>jalr</code>之后的寄存器<code>ra</code>中有什么值？</li>
</ol>
<blockquote>
<p>jalr指令会跳转到ra+1616的地方，并且令ra为下一次指令地址，因此为38</p>
</blockquote>
<p>执行以下代码显示的结果：576161&#x3D;&#x3D;0xE110，i&#x3D;0x00’64’6c’72，小端存储因此打印字符串就是<code>&#39;\0x72&#39;,&#39;\0x6c&#39;,&#39;\0x64&#39;,&#39;\0&#39;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s\n&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d\n&quot;</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ call</span><br><span class="line"><span class="number">12</span> <span class="number">13</span></span><br><span class="line">HE110 World</span><br><span class="line">x=<span class="number">3</span> y=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(PGROUNDUP(fp) == PGROUNDDOWN(fp) + PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-8</span>));</span><br><span class="line">    fp = *(uint64*)(fp<span class="number">-16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./../../pic/xv6/image-20241205210656004.png" alt="image-20241205210656004"></p>
<h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>添加系统调用，<code>alarm</code>需要进程记录触发时间间隔，计时器，处理函数，同时需要保存的寄存器，这里直接将整个trapfram保存起来了，在<code>allocproc</code>和<code>freeproc</code>初始化和释放新字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;alarminterval = interval;</span><br><span class="line">  myproc()-&gt;handler = (<span class="type">void</span>(*)())handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  *myproc()-&gt;trapframe = *myproc()-&gt;oldtrapframe;</span><br><span class="line">  myproc()-&gt;alarming = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>trap</code>触发timer interrupt处修改切换的程序，sepc存放用户指令地址，stvec存放内核指令地址，这里需要切换epc为handler，同时为了通过test2，不应该在触发alarm的时候在handler中再次触发alarm，因此添加alarming字段表明正在发生alarm</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span> &amp;&amp; p-&gt;alarming == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ticks &gt;= p-&gt;alarminterval)</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;alarming = <span class="number">1</span>;</span><br><span class="line">      *p-&gt;oldtrapframe = *p-&gt;trapframe;</span><br><span class="line">      p-&gt;trapframe-&gt;epc = (uint64)(p-&gt;handler);</span><br><span class="line">      p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab5：lazy-page-allocation"><a href="#lab5：lazy-page-allocation" class="headerlink" title="lab5：lazy page allocation"></a>lab5：lazy page allocation</h2><p><code>stval</code>包含无法被转换的地址，即缺页的那个地址</p>
<p>修改<code>sbrk</code>系统调用，当需要扩容时进行写时复制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    myproc()-&gt;sz += n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n + addr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(growproc(n) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>usertrap</code>当触发13或15页面错误则分配一个page，并且通过<code>vmprintf</code>看到分配了两个页</p>
<p>.. .. ..4: pte 0x0000000021fd64df pa 0x0000000087f59000<br>.. .. ..19: pte 0x0000000021fd601f pa 0x0000000087f58000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp) || va &gt;= myproc()-&gt;sz || uvmalloc(p-&gt;pagetable, PGROUNDDOWN(va), va+<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改出现<code>(pte = walk(pagetable, a, 0)) == 0</code>和<code>(*pte &amp; PTE_V) == 0</code>条件为true直接continue，不然报错</p>
<p>处理进程从<code>sbrk()</code>向系统调用（如<code>read</code>或<code>write</code>）传递有效地址，但尚未分配该地址的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 va = *ip;</span><br><span class="line">  <span class="keyword">if</span>(walkaddr(p-&gt;pagetable, *ip) == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span>(va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp) || va &gt;= myproc()-&gt;sz || uvmalloc(p-&gt;pagetable, PGROUNDDOWN(va), va+<span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab6-cow-fork"><a href="#lab6-cow-fork" class="headerlink" title="lab6: cow fork"></a>lab6: cow fork</h2><p>添加RSW标志位标志cow映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_RSW (1L &lt;&lt; 8) <span class="comment">// reserved</span></span></span><br></pre></td></tr></table></figure>

<p>因为父子进程共享页面，添加引用次数（同kmem添加自旋锁），因此在<code>kinit</code>初始化锁<code> initlock(&amp;ref.lock, &quot;ref&quot;);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ref_struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="type">int</span> refcnt[PHYSTOP/PGSIZE];</span><br><span class="line">&#125; ref;</span><br></pre></td></tr></table></figure>

<p>修改<code>kfree</code>判断引用次数为0才真正删除，修改<code>kalloc</code>设置页引用次数为1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(--ref.refcnt[(uint64)pa/PGSIZE] &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">release</span>(&amp;ref.lock);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r) &#123;</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line"><span class="built_in">acquire</span>(&amp;ref.lock);</span><br><span class="line">ref.refcnt[(uint64)r/PGSIZE] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为struct ref_struct在kalloc.c中，添加以下四个函数读取cnt，addcnt，判断是否PTE_RSW，写时分配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addrefcnt</span><span class="params">(uint64 pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ref.lock);</span><br><span class="line">  ++ref.refcnt[pa/PGSIZE];</span><br><span class="line">  <span class="built_in">release</span>(&amp;ref.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">refcnt</span><span class="params">(uint64 pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ref.refcnt[pa/PGSIZE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cowpage</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA || </span><br><span class="line">    (pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>)) == <span class="number">0</span> || (*pte &amp; PTE_RSW) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">cowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ref.refcnt[pa / PGSIZE] &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    *pte = (*pte | PTE_W) &amp; ~PTE_RSW;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)pa;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="type">char</span>* mem = <span class="built_in">kalloc</span>();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memmove</span>(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="type">int</span> flags = (<span class="built_in">PTE_FLAGS</span>(*pte) &amp; ~PTE_RSW) | PTE_W ;</span><br><span class="line">    *pte = <span class="built_in">PA2PTE</span>((uint64)mem) | flags;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)pa);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)mem;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>uvmalloc</code>（删除kalloc，修改映射关系到pa并且添加PTE_RSW标志)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flags &amp; PTE_W) &#123;</span><br><span class="line">  flags  = (flags &amp; ~PTE_W) | PTE_RSW;</span><br><span class="line">  *pte = <span class="built_in">PA2PTE</span>(pa) | flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>usertrap</code>当发生pagefault时写时复制</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">13</span> || <span class="built_in">r_scause</span>() == <span class="number">15</span>) &#123;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line"><span class="keyword">if</span>(va &gt;= p-&gt;sz || <span class="built_in">cowpage</span>(p-&gt;pagetable, va) != <span class="number">0</span> </span><br><span class="line">  || <span class="built_in">cowalloc</span>(p-&gt;pagetable, va) == <span class="number">0</span>) </span><br><span class="line">  p-&gt;killed = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>copyout</code>在遇到COW页面时使用同页面错误相同方案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">cowpage</span>(pagetable, va0) == <span class="number">0</span>) &#123;</span><br><span class="line">  pa0 = (uint64)<span class="built_in">cowalloc</span>(pagetable, va0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>记录错误：</p>
<p>发生scause&#x3D;5，sepc&#x3D;0x386错误，跟正确的对比才发现当PTE_W时设置flags出错，直接<code>*pte &amp;= flags;</code>错误地把除10位flags之外的位置零了</p>
<h2 id="lab7-multithreading"><a href="#lab7-multithreading" class="headerlink" title="lab7 multithreading"></a>lab7 multithreading</h2><h3 id="switching-between-threads"><a href="#switching-between-threads" class="headerlink" title="switching between threads"></a>switching between threads</h3><p>同进程swtch一样添加上下文切换，ra和sp，添加context字段，汇编代码同swtch一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t-&gt;context.ra = (uint64)func;</span><br><span class="line">t-&gt;context.sp = (uint64)t-&gt;stack+STACK_SIZE;</span><br></pre></td></tr></table></figure>

<h3 id="using-threads"><a href="#using-threads" class="headerlink" title="using threads"></a>using threads</h3><p>使用pthread_mutex_t确保多线程哈希表使用安全，为每个哈希桶分配lock，减少因为锁的性能下降</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET];</span><br></pre></td></tr></table></figure>

<h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;bstate.barrier_mutex);</span><br><span class="line"><span class="keyword">if</span>(++bstate.nthread == nthread) &#123;</span><br><span class="line">  ++bstate.round;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">pthread_cond_broadcast</span>(&amp;bstate.barrier_cond);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">pthread_cond_wait</span>(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;bstate.barrier_mutex);</span><br></pre></td></tr></table></figure>



<h2 id="lab8-locks"><a href="#lab8-locks" class="headerlink" title="lab8 locks"></a>lab8 locks</h2><h3 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h3><p>为每个cpu分配<code>struct kmem</code>，并且在<code>kalloc</code>空闲链表不足时窃取其他cpu的空闲链表的一部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> id = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[id].lock);</span><br><span class="line">  r = kmem[id].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[id].freelist = r-&gt;next;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">  <span class="keyword">if</span>(!r)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == id) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;kmem[i].lock);</span><br><span class="line">      r = kmem[i].freelist;</span><br><span class="line">      <span class="keyword">if</span>(r)</span><br><span class="line">        kmem[i].freelist = r-&gt;next;</span><br><span class="line">      <span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">      <span class="keyword">if</span>(r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">push_off</span>();</span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">cpuid</span>();</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;kmem[id].lock);</span><br><span class="line">    r-&gt;next = kmem[id].freelist;</span><br><span class="line">    kmem[id].freelist = r;</span><br><span class="line">    <span class="built_in">release</span>(&amp;kmem[id].lock);</span><br><span class="line">    <span class="built_in">pop_off</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h3><p>将bcache的单个缓存区链表替换为哈希表，用timestamp替换lru置换</p>
<p>添加哈希桶，根据trap.c的ticks实现timestamp并为struct buf添加ticks字段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 13</span></span><br><span class="line"><span class="type">const</span> uint UINT_MAX = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">spinlock</span> tick_lock;</span><br><span class="line">uint ttt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hashbuf</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> head;  <span class="comment">// 指向桶中的第一个buf</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> buf[NBUF];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">hashbuf</span> buckets[NBUCKET];</span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure>

<p>在<code>binit</code>初始化每个哈希桶的head</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">binit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initlock</span>(&amp;tick_lock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">  <span class="built_in">initlock</span>(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;bcache_%d&quot;</span>, i);</span><br><span class="line">    <span class="built_in">initlock</span>(&amp;bcache.buckets[i].lock, name);</span><br><span class="line"></span><br><span class="line">    bcache.buckets[i].head.prev = &amp;bcache.buckets[i].head;</span><br><span class="line">    bcache.buckets[i].head.next = &amp;bcache.buckets[i].head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create linked list of buffers</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    <span class="type">int</span> hash = (b - bcache.buf) % NBUCKET;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hashbuf</span> *hb = &amp;bcache.buckets[hash];</span><br><span class="line">    b-&gt;next = hb-&gt;head.next;</span><br><span class="line">    b-&gt;prev = &amp;hb-&gt;head;</span><br><span class="line">    <span class="built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    hb-&gt;head.next-&gt;prev = b;</span><br><span class="line">    hb-&gt;head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加tick函数进行计时，在<code>bget</code>函数中倘若当前哈希桶的buffer cache未命中，把no cached的情况单独拎出来写在nocached函数中同时进行串行化回收，这样<code>brelse</code>函数只需要修改时间戳同时避免锁争用，最终缓存区的回收只在<code>nocached</code>进行，需要一个全局锁用bcache.lock代替，注意将缓存区从一个哈希桶移动到另一个哈希桶的锁使用和释放时间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;tick_lock);</span><br><span class="line">  ret = ++ttt;</span><br><span class="line">  <span class="built_in">release</span>(&amp;tick_lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>* <span class="built_in">nocached</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b, *lru = <span class="number">0</span>;</span><br><span class="line">  uint min = UINT_MAX;</span><br><span class="line">  <span class="type">int</span> hash = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;bcache.buckets[i].lock);</span><br><span class="line">    <span class="keyword">for</span>(b = bcache.buckets[i].head.prev; b != &amp;bcache.buckets[i].head; b = b-&gt;prev)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; b-&gt;ticks &lt; min) &#123;</span><br><span class="line">        min = b-&gt;ticks;</span><br><span class="line">        lru = b;</span><br><span class="line">        hash = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;bcache.buckets[i].lock);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lru &amp;&amp; hash != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">    <span class="comment">// 从桶中移除lru</span></span><br><span class="line">    lru-&gt;next-&gt;prev = lru-&gt;prev;</span><br><span class="line">    lru-&gt;prev-&gt;next = lru-&gt;next;</span><br><span class="line">    <span class="built_in">release</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">    <span class="comment">// 移入新桶</span></span><br><span class="line">    hash = (dev+blockno) % NBUCKET;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">    lru-&gt;next = bcache.buckets[hash].head.next;</span><br><span class="line">    lru-&gt;prev = &amp;bcache.buckets[hash].head;</span><br><span class="line">    bcache.buckets[hash].head.next-&gt;prev = lru;</span><br><span class="line">    bcache.buckets[hash].head.next = lru;</span><br><span class="line"></span><br><span class="line">    lru-&gt;dev = dev;</span><br><span class="line">    lru-&gt;blockno = blockno;</span><br><span class="line">    lru-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    lru-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    lru-&gt;ticks = <span class="built_in">tick</span>();  <span class="comment">// 更新时间戳</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">    <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">    <span class="built_in">acquiresleep</span>(&amp;lru-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> lru;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>*</span><br><span class="line"><span class="built_in">bget</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line">  <span class="type">int</span> hash = (dev+blockno) % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buckets[hash].head.next; b != &amp;bcache.buckets[hash].head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      b-&gt;ticks = <span class="built_in">tick</span>();</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">nocached</span>(dev, blockno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holdingsleep</span>(&amp;b-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">releasesleep</span>(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> hash = (b-&gt;dev+b-&gt;blockno) % NBUCKET;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  b-&gt;ticks = <span class="built_in">tick</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.buckets[hash].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="lab9-file-system"><a href="#lab9-file-system" class="headerlink" title="lab9 file system"></a>lab9 file system</h2><h3 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h3><p>为inode一个二级间接块，添加和修改宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define NDIRECT 11</span><br><span class="line">#define NINDIRECT (BSIZE / sizeof(uint))</span><br><span class="line">#define N2INDIRECT (NINDIRECT * NINDIRECT)</span><br><span class="line">#define MAXFILE (NDIRECT + NINDIRECT + N2INDIRECT)</span><br></pre></td></tr></table></figure>

<p>修改<code>bmap</code>增加一下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(bn &lt; N2INDIRECT)&#123;</span><br><span class="line">  uint l2_idx = bn / NINDIRECT;</span><br><span class="line">  uint l1_idx = bn % NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">    ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((addr = a[l2_idx]) == <span class="number">0</span>)&#123;</span><br><span class="line">    a[l2_idx] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">    </span><br><span class="line">  bp = bread(ip-&gt;dev, addr);</span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((addr = a[l1_idx]) == <span class="number">0</span>) &#123;</span><br><span class="line">    a[l1_idx] = addr = balloc(ip-&gt;dev); </span><br><span class="line">    log_write(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>itrunc</code>增加以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">bp1</span>;</span></span><br><span class="line">uint *a1;</span><br><span class="line"><span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">  bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">  a = (uint*)bp-&gt;data;</span><br><span class="line">  <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]) &#123;</span><br><span class="line">      bp1 = bread(ip-&gt;dev, a[j]);</span><br><span class="line">      a1 = (uint*)bp1-&gt;data;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINDIRECT; i++)</span><br><span class="line">        <span class="keyword">if</span>(a1[i]) bfree(ip-&gt;dev, a1[i]);</span><br><span class="line">      brelse(bp1);</span><br><span class="line">      bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(bp);</span><br><span class="line">  bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">  ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h3><p>添加软连接系统调用，修改sys_open进行符号链接跟随，最大深度为10</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SYMLINK_DEPTH; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) != MAXPATH) &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">      <span class="keyword">if</span>(ip-&gt;type != T_SYMLINK)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK) &#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="keyword">if</span>((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) != MAXPATH) &#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我在参考<code>sys_link</code>后调用<code>sys_symlink</code>系统调用的时候发生了死锁，发现在<code>create</code>函数中已经对创建的inode进行加锁，因此调用create后无需再加锁</p>
<h2 id="lab10：mmap"><a href="#lab10：mmap" class="headerlink" title="lab10：mmap"></a>lab10：mmap</h2><h2 id="lab11：Network-driver"><a href="#lab11：Network-driver" class="headerlink" title="lab11：Network driver"></a>lab11：Network driver</h2></article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/covers/17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img class="cover" src="/img/covers/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">面试题</div></div><div class="info-2"><div class="info-item-1"> c++枚举1、C 枚举类型支持不同类型枚举值之间赋值、以及数字赋值、比较，并且具有外层作用域。 2、C++ 中枚举不允许不同类型的值给枚举类型变量赋值，但仍然支持不同类型之间枚举进行比较，枚举符号常量具有外层作用域。 3、C++...</div></div></div></a><a class="pagination-related" href="/go/" title="go"><img class="cover" src="/img/covers/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">go</div></div><div class="info-2"><div class="info-item-1"> gobyeaxmple 介绍并发编程	异步模型 1、seamless轻量级跨核心抢占式 2、csp and shared by communicating goroutines比线程切换快10倍，运行时增长栈，消除同步与异步代码之间区别 使用语言内建的通道消除锁需求 安装： rm -rf &#x2F;usr&#x2F;local &amp;&amp; tar -xvf &#x2F;usr&#x2F;local xxx go mod ini：初始化你的代码模块，通常为保存源代码的存储库路径 1234567package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, World!&quot;)&#125;  跟py挺像的，导入fmt包，也可以通过go mod tidy导入别人的包 如import &quot;rsc.io/quote&quot;，也可以通过go build生成二进制文件 123456package mainimport &quot;fmt&quot;import...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#book-riscv"><span class="toc-number">1.</span> <span class="toc-text">book-riscv</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trap-and-syscall"><span class="toc-number">1.4.</span> <span class="toc-text">trap and syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%B7%E5%85%A5trap%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">陷入trap机制：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Page-fault"><span class="toc-number">1.4.2.</span> <span class="toc-text">Page-fault</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.</span> <span class="toc-text">中断和设备驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6"><span class="toc-number">1.7.</span> <span class="toc-text">调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep%E5%92%8Cwakeup"><span class="toc-number">1.7.2.</span> <span class="toc-text">sleep和wakeup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-cache%E5%B1%82"><span class="toc-number">1.8.1.</span> <span class="toc-text">Buffer cache层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%B1%82"><span class="toc-number">1.8.2.</span> <span class="toc-text">日志层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode%E5%B1%82"><span class="toc-number">1.8.3.</span> <span class="toc-text">inode层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E5%B1%82"><span class="toc-number">1.8.4.</span> <span class="toc-text">目录层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%90%8D%E5%B1%82"><span class="toc-number">1.8.5.</span> <span class="toc-text">路径名层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">文件系统可靠性：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lab"><span class="toc-number">2.</span> <span class="toc-text">lab</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lab1-util"><span class="toc-number">2.1.</span> <span class="toc-text">lab1 util</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab2-syscall"><span class="toc-number">2.2.</span> <span class="toc-text">lab2 syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-call-tracing"><span class="toc-number">2.2.1.</span> <span class="toc-text">system call tracing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysinfo"><span class="toc-number">2.2.2.</span> <span class="toc-text">sysinfo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab3-pgtb"><span class="toc-number">2.3.</span> <span class="toc-text">lab3 pgtb</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vmprint"><span class="toc-number">2.3.1.</span> <span class="toc-text">vmprint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-kernel-page-table-per-process"><span class="toc-number">2.3.2.</span> <span class="toc-text">A kernel page table per process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Simplify-copyin-copyinstr"><span class="toc-number">2.3.3.</span> <span class="toc-text">Simplify copyin&#x2F;copyinstr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab4-trap"><span class="toc-number">2.4.</span> <span class="toc-text">lab4 trap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#risc-v-assembly"><span class="toc-number">2.4.1.</span> <span class="toc-text">risc-v assembly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#backtrace"><span class="toc-number">2.4.2.</span> <span class="toc-text">backtrace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alarm"><span class="toc-number">2.4.3.</span> <span class="toc-text">alarm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab5%EF%BC%9Alazy-page-allocation"><span class="toc-number">2.5.</span> <span class="toc-text">lab5：lazy page allocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab6-cow-fork"><span class="toc-number">2.6.</span> <span class="toc-text">lab6: cow fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab7-multithreading"><span class="toc-number">2.7.</span> <span class="toc-text">lab7 multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#switching-between-threads"><span class="toc-number">2.7.1.</span> <span class="toc-text">switching between threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using-threads"><span class="toc-number">2.7.2.</span> <span class="toc-text">using threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#barrier"><span class="toc-number">2.7.3.</span> <span class="toc-text">barrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab8-locks"><span class="toc-number">2.8.</span> <span class="toc-text">lab8 locks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-allocator"><span class="toc-number">2.8.1.</span> <span class="toc-text">Memory allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer-cache"><span class="toc-number">2.8.2.</span> <span class="toc-text">Buffer cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab9-file-system"><span class="toc-number">2.9.</span> <span class="toc-text">lab9 file system</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-files"><span class="toc-number">2.9.1.</span> <span class="toc-text">Large files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbolic-links"><span class="toc-number">2.9.2.</span> <span class="toc-text">Symbolic links</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab10%EF%BC%9Ammap"><span class="toc-number">2.10.</span> <span class="toc-text">lab10：mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lab11%EF%BC%9ANetwork-driver"><span class="toc-number">2.11.</span> <span class="toc-text">lab11：Network driver</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Jerold</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>