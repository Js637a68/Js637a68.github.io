<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ext2 &amp;&amp; simple filesystem实现 | Jerold‘s PNote</title><meta name="author" content="Jerold"><meta name="copyright" content="Jerold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前导知识磁盘组成(机械硬盘)盘片：下图包含三个盘片，一般在五片以内，盘片编号自下向上从0开始 片面：每个盘片有两个片面，最下盘片有0面和1面 磁头：每个片面对应一个读写磁头 磁道：一个片面分为一条条同心圆的磁道 扇区：磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区，磁盘最小组成单元，通常512字节 柱面：每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形">
<meta property="og:type" content="article">
<meta property="og:title" content="ext2 &amp;&amp; simple filesystem实现">
<meta property="og:url" content="http://example.com/%E9%A1%B9%E7%9B%AE/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Jerold‘s PNote">
<meta property="og:description" content="前导知识磁盘组成(机械硬盘)盘片：下图包含三个盘片，一般在五片以内，盘片编号自下向上从0开始 片面：每个盘片有两个片面，最下盘片有0面和1面 磁头：每个片面对应一个读写磁头 磁道：一个片面分为一条条同心圆的磁道 扇区：磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区，磁盘最小组成单元，通常512字节 柱面：每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/9.jpg">
<meta property="article:published_time" content="2024-07-18T16:43:45.000Z">
<meta property="article:modified_time" content="2024-07-18T16:43:45.000Z">
<meta property="article:author" content="Jerold">
<meta property="article:tag" content="ext2">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/9.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/%E9%A1%B9%E7%9B%AE/ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ext2 && simple filesystem实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/9.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jerold‘s PNote</span></a><a class="nav-page-title" href="/"><span class="site-name">ext2 &amp;&amp; simple filesystem实现</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">ext2 &amp;&amp; simple filesystem实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-18T16:43:45.000Z" title="发表于 2024-07-19 2024-07-19T00:43:45+08:00">2024-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-18T16:43:45.000Z" title="更新于 2024-07-19 2024-07-19T00:43:45+08:00">2024-07-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<hr>
<h2 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h2><h3 id="磁盘组成-机械硬盘"><a href="#磁盘组成-机械硬盘" class="headerlink" title="磁盘组成(机械硬盘)"></a>磁盘组成(机械硬盘)</h3><p><strong>盘片：</strong>下图包含三个盘片，一般在五片以内，盘片编号自下向上从0开始</p>
<p><strong>片面：</strong>每个盘片有两个片面，最下盘片有0面和1面</p>
<p><strong>磁头：</strong>每个片面对应一个读写磁头</p>
<p><strong>磁道：</strong>一个片面分为一条条同心圆的磁道</p>
<p><strong>扇区：</strong>磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区，<strong>磁盘最小组成单元，通常512字节</strong></p>
<p><strong>柱面：</strong>每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个柱面</p>
<p><img src="/./../../pic/ext2/tx1zz26zx6.png" alt="img"></p>
<p><strong>磁盘容量：</strong>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 磁道扇区数 × 每扇区字节数</p>
<blockquote>
<p>老硬盘内外圈密度小，内圈密度大，每个磁道可存储大小一样；</p>
<p>新磁盘密度都一样，越靠外，容量越大</p>
</blockquote>
<p><strong>响应时间</strong></p>
<p>1、寻道时间：磁头从开始移动到数据所在磁道所需要的时间，一般10ms</p>
<p>2、旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间</p>
<p>3、数据传输时间：完成传输所请求的数据所需要的时间。</p>
<p><strong>扇区、块&#x2F;簇、page的关系</strong></p>
<ol>
<li>扇区： 硬盘的最小读写单元</li>
<li>块&#x2F;簇： 是操作系统针对硬盘读写的最小单元</li>
<li>page： 是内存与操作系统之间操作的最小单元。</li>
</ol>
<h2 id="ext家族"><a href="#ext家族" class="headerlink" title="ext家族"></a>ext家族</h2><h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3><p><strong>block：</strong>一个扇区512字节，block出现提高了读写性能，一个block一般1k、2k、4k</p>
<p>文件系统维护数据块，磁盘维护逻辑块，</p>
<p>IO管理器将数据块翻译成逻辑块地址LBA</p>
<p><strong>inode：</strong>索引节点，目的是索引数据，优化存储</p>
<blockquote>
<p>一般来说索引占用的空间相比其索引的文件数据而言占用的空间就小得多，扫描它比扫描整个数据要快得多，否则索引就没有存在的意义。这样一来就解决了前面所有的问题。</p>
</blockquote>
<p>在inode中存储了inode号、文件类型、权限、文件所有者、大小、时间戳等元数据信息，最重要的是还存储了指向属于该文件block的指针</p>
<p>一般inode大小为128字节或256字节</p>
<blockquote>
<p>文件系统创建完成后所有的inode号都已经分配好并记录到inode table中了，只不过被使用的inode号所在的行还有文件属性的元数据信息和block位置信息，而未被使用的inode号只有一个inode号而没有其他信息而已。</p>
</blockquote>
<p><strong>bmap：</strong></p>
<p>位图只使用0和1标识对应block是空闲还是被占用，0和1在位图中的位置和block的位置一一对应</p>
<p>写优化——对于block为4K而言，1G文件只要32K位图就能一一对应</p>
<p><strong>inode表：</strong>通过将存储inode的block组合起来形成一张表</p>
<p><strong>imap：</strong>标识空闲inode</p>
<p><strong>块组(逻辑上)：</strong>减小map大小，提高map扫描效率</p>
<p>解决文件太大，文件系统太大导致bmap、imap太大，效率低下问题</p>
<p>磁盘分区即多个文件系统，逻辑分组即将一个文件系统分为多个块组</p>
<p>每个块组包含多个元数据区和数据区：元数据区就是存储bmap、inode table、imap等的数据；数据区就是存储文件数据的区域。</p>
<p>块组在文件系统创建就划分好了——约定bmap至多占用一个block(包含数据和元数据)</p>
<p>使用dumpe2fs可以将ext类的文件系统信息全部显示出来，当然bmap是每个块组固定一个block的不用显示，imap比bmap更小所以也只占用1个block不用显示。</p>
<p><img src="/./../../pic/ext2/f4415d72e628afc7cf39edd5b8cb747c.jpeg" alt="好文分享：ext文件系统机制原理详解"></p>
<p>文件系统大小： block count * block size</p>
<p>块组数量：fs size &#x2F; blocks per group</p>
<h3 id="文件系统的完整结构"><a href="#文件系统的完整结构" class="headerlink" title="文件系统的完整结构"></a>文件系统的完整结构</h3><p>约定：superblock、bmap、imap占用一个block</p>
<p><img src="/./../../pic/ext2/image-20241119011444974.png" alt="image-20241119011444974"></p>
<p><strong>引导块：</strong>分区第一个块，1024字节，只有装了os的主分区和装了os的逻辑分区才有，里面存放boot loader，这段boot loader称为VBR(主分区装操作系统时)或EBR(扩展分区装操作系统时)</p>
<p>首先MBR上的boot loader加载后，通过指针-&gt;定位到不同操作系统VBR的bootloader</p>
<p><img src="/./../../pic/ext2/339a24640e5dfde7ebc9e338b815e2ae.jpeg" alt="好文分享：ext文件系统机制原理详解"></p>
<blockquote>
<p>这种OS菜单已弃用</p>
</blockquote>
<p><strong>超级块：</strong>描述块组结构，存储文件系统本身的属性信息如各种时间戳、每个块组又有多少block多少inode号、block总数量和空闲数量、inode总数量和空闲数量、当前文件系统是否正常、什么时候需要自检等等</p>
<blockquote>
<p>df：读取每个操作系统的superblock</p>
<p>du：遍历目录所有文件</p>
</blockquote>
<p>ext2在0、1块组和3、5、7幂次方的块组保存超级块，只用到块组0的superblock，其余作为备份(重要信息)；当block大于1k时，<strong>引导块和超级块放一起</strong></p>
<blockquote>
<p>通过dumpe2fs -h读取ext超级块信息</p>
</blockquote>
<p><strong>GDT：</strong>每个块组描述符32字节记录了块组的信息和属性元数据，所有块组描述符组成GDT，gdt也是重要数据，页需要备份，存放位置和读取同superblock一样，可以通过dumpe2fs获取描述符信息</p>
<p><strong>保留GDT：</strong>用于扩容文件系统</p>
<p><strong>data block</strong>：</p>
<ul>
<li>对于常规文件，文件的数据正常存储在数据块中。</li>
<li>对于目录，该目录下的所有文件和一级子目录的目录名存储在数据块中。</li>
<li>文件名不是存储在其自身的inode中，而是存储在其所在目录的data block中。</li>
<li>对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。</li>
<li>设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。</li>
</ul>
<p><strong>目录文件：</strong></p>
<p>目录文件inode中存储目录的inode链接，类型，名字，因此没有执行权限时无法获取inode号，需要执行inode链接</p>
<p>name属性：4的倍数，’\0‘填充，</p>
<p>unlink：删除这个指针和inode号的映射，例子：ls -l无法获取没有执行权限的inode号</p>
<p>‘.’和’..‘两个硬链接</p>
<p><img src="/./../../pic/ext2/image-20241119013626515.png" alt="image-20241119013626515"></p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>inode-&gt;block-&gt;file</p>
<p><strong>硬链接</strong>：inode相同，不允许跨区</p>
<p>删除本质就是应删除目录对应inode的指针</p>
<p>In file_target link_name</p>
<p><strong>软连接：</strong></p>
<p>符号链接：软连接，相当于快捷方式，大小是目标路径字符个数</p>
<p>符号链接的inode记录就能描述信息，目标路径60字节时才会分配block<br>设备文件、FIFO、套接字文件没有data block</p>
<p>In -s source_file softlink_name</p>
<p>readlink softlink_name</p>
<p><strong>深入：</strong></p>
<p>cat &#x2F;etc&#x2F;mke2fs.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blocksize = 4096 </span><br><span class="line">inode_size = 256 </span><br><span class="line">inode_ratio = 16384</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>Ext4的特殊inode</li>
<li>Inode号 用途</li>
<li>0 不存在0号inode</li>
<li>1 虚拟文件系统，如&#x2F;proc和&#x2F;sys</li>
<li>2 根目录</li>
<li>3 ACL索引</li>
<li>4 ACL数据</li>
<li>5 Boot loader</li>
<li>6 未删除的目录</li>
<li>7 预留的块组描述符inode</li>
<li>8 日志inode</li>
<li>11 第一个非预留的inode，通常是lost+found目录</li>
</ul>
</blockquote>
<p>ext2&#x2F;3inode指针</p>
<p>最多15个，前12个是直接寻址</p>
<p>12+256+256^2+25^4</p>
<h3 id="单文件系统："><a href="#单文件系统：" class="headerlink" title="单文件系统："></a>单文件系统：</h3><p>读取cat &#x2F;vat&#x2F;log&#x2F;message</p>
<p>找到GDT–&gt;找到”&#x2F;“的inode–&gt;找到&#x2F;的数据块读取var的inode–&gt;找到var的数据块读取log的inode–&gt;找到log的数据块读取messages的inode–&gt;找到messages的数据块并读取它们</p>
<p>删除</p>
<p>(1)找到文件的inode和data block;</p>
<p>(2)将inode table中该inode记录中的data block指针删除;</p>
<p>(3)在imap中将该文件的inode号标记为未使用;</p>
<p>(4)在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针;</p>
<p>(5)将bmap中data block对应的block号标记为未使用。</p>
<p><strong>删除目录：</strong>所有inode和data block，3、5，提前删除父目录记录报错目录非空</p>
<p>第五步中df仍会计算大小</p>
<p>当一个进程正在引用文件时将该文件删除，就会出现文件已删除但空间未释放的情况。这时步骤已经进行到(4)，外界无法再找到该文件，但由于进程在加载该文件时已经获取到了该文件所有的data block指针，该进程可以获取到该文件的所有数据，但却暂时不会释放该文件空间。直到该进程结束，文件系统才将未执行的步骤(5)继续完成。这也是为什么有时候du的统计结果比df小的原因</p>
<p><strong>存储和复制：</strong></p>
<p>每存储一个block调用一次block分配器</p>
<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>文件系统需要挂载才能使用</p>
<p>将文件系统挂载到一个目录后，该目录是文件系统的入口：</p>
<p>在父目录文件系统的inode表中，重新分配一个inode，其block指针指向新的文件系统，指向老inode的指针现在指向新inode，原来的目录就被标记不可用</p>
<p>卸载时移除新配分的inode，将父目录的data block的指针指向老inode</p>
<p><strong>ext3：</strong></p>
<p>数据区、日志区、元数据区</p>
<p>先在日志保存元数据</p>
<p><strong>ex4：</strong></p>
<p>使用extent段来管理，inode寻址使用片断流，设定了起始block号和连续block</p>
<h2 id="A-SimpleFS"><a href="#A-SimpleFS" class="headerlink" title="A SimpleFS"></a>A SimpleFS</h2><p>Magic：文件系统的“签名”，意味着包含有效文件系统</p>
<h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><p>当遇到错误时可以去看一下shell和test脚本，为了看到错误信息，把test脚本 2&gt; &#x2F;dev&#x2F;null删掉，这是把cerr输出的错误信息丢掉</p>
<ol start="0">
<li><p>debug：没办法只能暴力照着格式输出，后来才发现printf磁盘读写次数应该在dis_close函数里打印，这样逻辑才对</p>
</li>
<li><p>format：这里format只能把除了superblock的每个block清空，我一开始尝试着只把inode表清空，虽然存储结果正确，但是因为test还要符合磁盘读写次数，而且读数据的时候还会出问题，所以还是要遍历删除</p>
</li>
<li><p>mount：记得unmount的时候要令fs-&gt;disk&#x3D;NULL，不然程序会abort，同时在最后两个测试报错了：可用看出这里直接修改超级块，每个superblock刚好4*4字节，而0xf0 0x f0 0x 34 0x10是魔数对应小端存储就是了；报错是因为，修改了inodes和inode_blocks不匹配了，在mount中还需检查inodes和inode_blocks值是否符合逻辑；最后read多了1因为把无效inode也读了</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x10 0x34 0xf0 0xf0) &gt;  <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x05 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x02 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x80 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Testing bad-mount on <span class="variable">$SCRATCH</span>/image.5 ... &quot;</span></span><br><span class="line"><span class="keyword">if</span> diff -u &lt;(bad-mount-input| ./bin/sfssh <span class="variable">$SCRATCH</span>/image.5 5 2&gt; /dev/null) &lt;(bad-mount-output) &gt; <span class="variable">$SCRATCH</span>/test.log; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Success&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Failure&quot;</span></span><br><span class="line">    <span class="built_in">cat</span> <span class="variable">$SCRATCH</span>/test.log</span><br><span class="line">    EXIT=$((<span class="variable">$EXIT</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x10 0x34 0xf0 0xf0) &gt;  <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x05 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x01 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n -e $(<span class="built_in">printf</span> <span class="string">&#x27;\\x%x\\x%x\\x%x\\x%x&#x27;</span> 0x70 0x00 0x00 0x00) &gt;&gt; <span class="variable">$SCRATCH</span>/image.5</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Testing bad-mount on <span class="variable">$SCRATCH</span>/image.5 ... &quot;</span></span><br><span class="line"><span class="keyword">if</span> diff -u &lt;(bad-mount-input| ./bin/sfssh <span class="variable">$SCRATCH</span>/image.5 5 2&gt; /dev/null) &lt;(bad-mount-output) &gt; <span class="variable">$SCRATCH</span>/test.log; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Success&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Failure&quot;</span></span><br><span class="line">    <span class="built_in">cat</span> <span class="variable">$SCRATCH</span>/test.log</span><br><span class="line">    EXIT=$((<span class="variable">$EXIT</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>stat：这一个测试内存容易出问题，最好用valgrind测试内存</p>
</li>
<li><p>create：我这里disk block read原本是要比测试少127次的，因为测试中认为你采用分而治之的思想，把save inode和load inode写在fs_load_inode和fs_save_inode中，因此包装在fs_save_inode就好了</p>
</li>
<li><p>fs_read：犯了一个弱智错误，每次读取间接block都从0开始读，忘记计算offset，😵</p>
</li>
<li><p>fs_write：copyin分配block，一开始直接fs_create()，才发现这是分配inode；原本设置true未使用，因为bool类型memset设置为0更方便并且不会出错，memset是通过一个字节一个字节赋值的，一般用0，-1，0x3f；</p>
<p>这里要确保fs_initialize_free_block_bitmap正确，不然读取inode信息可能读出一大串数据；</p>
<p>fs_write除了要保存inode，若有还需要保存indirect block</p>
</li>
<li><p>remove：在这一个测试一直报错，一直以为是remove的问题，导致write断言出错，最大用gdb才发现索引16的block已经在之前给我覆盖了，在这里刚好被拿来当作indirect block，导致直接越界，悲剧了，发现是这样一句话</p>
</li>
</ol>
<p><img src="/./../../pic/ext2/image-20241121230228035.png" alt="image-20241121230228035"></p>
<p>后面发现原本数据就是这样的需要你去判断，我的代码逻辑错了，应该在每次成功分配到block号时初始化block并覆盖掉，而不是再去读磁盘block</p>
<p>边界问题：</p>
<p>像fs_create，fs_write都要处理边界问题不能单纯的返回错误，比如fs_write当写满时还要更新inode</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>代码地址：<a target="_blank" rel="noopener" href="https://github.com/Js637a68/Simple-File-System">https://github.com/Js637a68/Simple-File-System</a></p>
<h4 id="磁盘模拟器"><a href="#磁盘模拟器" class="headerlink" title="磁盘模拟器"></a>磁盘模拟器</h4><p>把一个二进制文件模拟磁盘，对其进行读写操作，需要考虑字节序和内存对齐问题</p>
<p>创建二进制文件：<code>dd if=/dev/zero of=/path/file bs=1k count=4</code></p>
<p>修改二进制文件：<code>echo -n -e $(printf &#39;\\x%x\\x%x\\x%x\\x%x&#39; 0x10 0x34 0xf0 0xf0) &gt;&gt;  path/file</code></p>
<p>-n表示不要末尾添加换行符，-e启动转义字符，<code>\\x%x</code>表示一个字节的十六进制输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Disk</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>	    fd;	        <span class="comment">/* File descriptor of disk image	*/</span></span><br><span class="line">    <span class="type">size_t</span>  blocks;     <span class="comment">/* Number of blocks in disk image	*/</span></span><br><span class="line">    <span class="type">size_t</span>  reads;      <span class="comment">/* Number of reads to disk image	*/</span></span><br><span class="line">    <span class="type">size_t</span>  writes;     <span class="comment">/* Number of writes to disk image	*/</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Disk *	<span class="title function_">disk_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">size_t</span> blocks)</span> &#123;</span><br><span class="line">    Disk *disk = (Disk*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Disk));</span><br><span class="line">    <span class="keyword">if</span>(disk == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    disk-&gt;fd = open(path, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (ftruncate(disk-&gt;fd, blocks * BLOCK_SIZE) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        close(disk-&gt;fd);</span><br><span class="line">        <span class="built_in">free</span>(disk);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    disk-&gt;blocks = blocks;</span><br><span class="line">    disk-&gt;writes = disk-&gt;reads = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> disk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>	<span class="title function_">disk_close</span><span class="params">(Disk *disk)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(disk != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(disk-&gt;fd &gt;= <span class="number">0</span>) close(disk-&gt;fd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu disk block reads\n&quot;</span>, disk-&gt;reads);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lu disk block writes\n&quot;</span>, disk-&gt;writes);</span><br><span class="line">        <span class="built_in">free</span>(disk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">disk_read</span><span class="params">(Disk *disk, <span class="type">size_t</span> block, <span class="type">char</span> *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!disk_sanity_check(disk, block, data)) <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> position = (<span class="type">off_t</span>)block * BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (lseek(disk-&gt;fd, position, SEEK_SET) == (<span class="type">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> bytesRead = read(disk-&gt;fd, data, BLOCK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disk-&gt;reads++;</span><br><span class="line">    <span class="keyword">return</span> bytesRead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">disk_write</span><span class="params">(Disk *disk, <span class="type">size_t</span> block, <span class="type">char</span> *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!disk_sanity_check(disk, block, data)) <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> position = (<span class="type">off_t</span>)block * BLOCK_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (lseek(disk-&gt;fd, position, SEEK_SET) == (<span class="type">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> bytesWritten = write(disk-&gt;fd, data, BLOCK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> DISK_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disk-&gt;writes++;</span><br><span class="line">    <span class="keyword">return</span> bytesWritten;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>    <span class="title function_">disk_sanity_check</span><span class="params">(Disk *disk, <span class="type">size_t</span> block, <span class="type">const</span> <span class="type">char</span> *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(disk != <span class="literal">NULL</span> &amp;&amp; data != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( block &lt; disk-&gt;blocks)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>这里巧妙的应用union来表示一个block的类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC_NUMBER        (0xf0f03410)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INODES_PER_BLOCK    (128)               <span class="comment">/* <span class="doctag">TODO:</span> Number of inodes per block */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POINTERS_PER_INODE  (5)                 <span class="comment">/* <span class="doctag">TODO:</span> Number of direct pointers per inode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POINTERS_PER_BLOCK  (1024)              <span class="comment">/* <span class="doctag">TODO:</span> Number of pointers per block */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File System Structures */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span> <span class="title">SuperBlock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuperBlock</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    magic_number;                   <span class="comment">/* File system magic number */</span></span><br><span class="line">    <span class="type">uint32_t</span>    blocks;                         <span class="comment">/* Number of blocks in file system */</span></span><br><span class="line">    <span class="type">uint32_t</span>    inode_blocks;                   <span class="comment">/* Number of blocks reserved for inodes */</span></span><br><span class="line">    <span class="type">uint32_t</span>    inodes;                         <span class="comment">/* Number of inodes in file system */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Inode</span>      <span class="title">Inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inode</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    valid;                          <span class="comment">/* Whether or not inode is valid */</span></span><br><span class="line">    <span class="type">uint32_t</span>    size;                           <span class="comment">/* Size of file */</span></span><br><span class="line">    <span class="type">uint32_t</span>    direct[POINTERS_PER_INODE];     <span class="comment">/* Direct pointers */</span></span><br><span class="line">    <span class="type">uint32_t</span>    indirect;                       <span class="comment">/* Indirect pointers */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>  <span class="title">Block</span>      <span class="title">Block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">    SuperBlock  super;                          <span class="comment">/* View block as superblock */</span></span><br><span class="line">    Inode       inodes[INODES_PER_BLOCK];       <span class="comment">/* View block as inode */</span></span><br><span class="line">    <span class="type">uint32_t</span>    pointers[POINTERS_PER_BLOCK];   <span class="comment">/* View block as pointers */</span></span><br><span class="line">    <span class="type">char</span>        data[BLOCK_SIZE];               <span class="comment">/* View block as data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FileSystem</span> <span class="title">FileSystem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    Disk        *disk;                          <span class="comment">/* Disk file system is mounted on */</span></span><br><span class="line">    <span class="type">bool</span>        *free_blocks;                   <span class="comment">/* Free block bitmap */</span></span><br><span class="line">    SuperBlock   meta_data;                     <span class="comment">/* File system meta data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件系统属性打印：输出superblock和inode的信息，没什么好说遍历就好了</p>
<p>文件格式化：获取磁盘属性并设置超级块，这里把10%的块分配给inode表，因此需要把除超级块之外block都清0；在这里假定格式化一个已挂载的fs无效，满足以下条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!fs) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">size_t</span> blocks = disk-&gt;blocks;</span><br><span class="line"><span class="keyword">if</span> (blocks &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 磁盘块数不足，无法格式化</span></span><br></pre></td></tr></table></figure>

<p>挂载：挂载首先要检查魔数以及超级块属性是否合法，特别的，inode数量是否符合inode表，然后再初始化bmap表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span>    <span class="title function_">fs_mount</span><span class="params">(FileSystem *fs, Disk *disk)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (block.super.magic_number != MAGIC_NUMBER || block.super.blocks != disk-&gt;blocks)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(block.super.inodes != block.super.inode_blocks * INODES_PER_BLOCK) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bmap初始化，这里都是用c所以malloc，同样遍历inode，因为文件存放在inode块指针是按顺序的，不然文件数据有效无法保证，所以当0时可用break</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">1</span>; i &lt;= inode_blocks; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    fs-&gt;free_blocks[i] = <span class="literal">true</span>;     <span class="comment">// 被inode使用</span></span><br><span class="line">    Block b = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 读取inode表</span></span><br><span class="line">    assert(disk_read(fs-&gt;disk, i, b.data) != DISK_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; INODES_PER_BLOCK; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> Inode inode = b.inodes[p];</span><br><span class="line">        <span class="keyword">if</span>(!inode.valid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 直接block</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> j = <span class="number">0</span> ; j &lt; POINTERS_PER_INODE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inode.direct[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            fs-&gt;free_blocks[inode.direct[j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 间接block</span></span><br><span class="line">        <span class="keyword">if</span>(inode.indirect == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        fs-&gt;free_blocks[inode.indirect] = <span class="literal">true</span>;</span><br><span class="line">        Block indirect_point = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        assert(disk_read(fs-&gt;disk, inode.indirect, indirect_point.data) != DISK_FAILURE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; POINTERS_PER_BLOCK; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(indirect_point.pointers[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            fs-&gt;free_blocks[indirect_point.pointers[j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建inode和移除inode：这里的remove其实我只是简单的设置bmap未使用，将这个block清0的操作在分配这个block的时候进行，因为我发现一开始的image映像有许多冗余数据，有可能该block未使用但是依然保存无效数据，所以干脆省事在分配的时候再清0，为了方便操作这里需要额外两个函数来读取和存储inode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span> ; i &lt; POINTERS_PER_INODE; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(inode.direct[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    fs-&gt;free_blocks[inode.direct[i]] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(inode.indirect != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Block block = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    assert(disk_read(fs-&gt;disk, inode.indirect, block.data) != DISK_FAILURE);  </span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; POINTERS_PER_BLOCK; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(block.pointers[i] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        fs-&gt;free_blocks[block.pointers[i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i! = <span class="number">0</span>) fs-&gt;free_blocks[inode.indirect] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span>    <span class="title function_">fs_load_inode</span><span class="params">(FileSystem *fs, <span class="type">size_t</span> inode_number, Inode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    Block block = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(inode_number &gt;= fs-&gt;meta_data.inodes) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    assert(disk_read(fs-&gt;disk, inode_number/INODES_PER_BLOCK + <span class="number">1</span>, block.data) != DISK_FAILURE);</span><br><span class="line">    <span class="keyword">if</span>(!block.inodes[inode_number].valid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *node = block.inodes[inode_number % INODES_PER_BLOCK];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>    <span class="title function_">fs_save_inode</span><span class="params">(FileSystem *fs, <span class="type">const</span> <span class="type">size_t</span> inode_number, Inode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    Block block = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(inode_number &gt;= fs-&gt;meta_data.inodes) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    assert(disk_read(fs-&gt;disk, inode_number/INODES_PER_BLOCK + <span class="number">1</span>, block.data) != DISK_FAILURE);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;block.inodes[inode_number % INODES_PER_BLOCK], node, <span class="keyword">sizeof</span>(Inode));</span><br><span class="line">    assert(disk_write(fs-&gt;disk, inode_number/INODES_PER_BLOCK + <span class="number">1</span>, block.data) != DISK_FAILURE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读文件的话计算好偏移值就行，代码有重复的部分可用简洁一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Inode node = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (!fs_load_inode(fs, inode_number, &amp;node)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset &gt;= node.size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (offset + length &gt;= node.size) length = node.size - offset;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> i = offset / BLOCK_SIZE;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; POINTERS_PER_INODE &amp;&amp; sum &lt; length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.direct[i] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">    <span class="type">char</span> block_data[BLOCK_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(block_data, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">    assert(disk_read(fs-&gt;disk, node.direct[i], block_data) != DISK_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> read_size = (length - sum) &lt; BLOCK_SIZE ? (length - sum) : BLOCK_SIZE;</span><br><span class="line">    <span class="built_in">memcpy</span>(data + sum, block_data + offset % BLOCK_SIZE, read_size);</span><br><span class="line">    sum += read_size;</span><br><span class="line">    offset += read_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node.indirect != <span class="number">0</span> &amp;&amp; sum &lt; length) </span><br><span class="line">&#123;</span><br><span class="line">    Block block;</span><br><span class="line">    i -= POINTERS_PER_INODE;</span><br><span class="line">    assert(i &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(disk_read(fs-&gt;disk, node.indirect, block.data) != DISK_FAILURE);</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; POINTERS_PER_BLOCK &amp;&amp; sum &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (block.pointers[i] == <span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">        <span class="type">char</span> block_data[BLOCK_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>(block_data, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">        assert(disk_read(fs-&gt;disk, block.pointers[i], block_data) != DISK_FAILURE); </span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> read_size = (length - sum) &lt; BLOCK_SIZE ? (length - sum) : BLOCK_SIZE;</span><br><span class="line">        <span class="built_in">memcpy</span>(data + sum, block_data + offset % BLOCK_SIZE, read_size);</span><br><span class="line">        sum += read_size;</span><br><span class="line">        offset += read_size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写文件操作比较复杂，这里根据offset选取从哪一个block开始写，考虑是否需要分配block，不然就直接读出block进行写入，每write一个block从offset%BLOCK_SIZE开始到BLOCK_SIZE这段区间写入，判断length是否到头了，真正写入的是copy_size；第二部分读取间接block，同理，这里重复了代码有点冗余；如果磁盘没有足够空间可用分配就goto last</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">fs_write</span><span class="params">(FileSystem *fs, <span class="type">size_t</span> inode_number, <span class="type">char</span> *data, <span class="type">size_t</span> length, <span class="type">size_t</span> offset)</span> &#123;</span><br><span class="line">    Inode node;</span><br><span class="line">    <span class="keyword">if</span>(!fs_load_inode(fs, inode_number, &amp;node)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(offset &gt; node.size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> point = offset / BLOCK_SIZE;</span><br><span class="line">    <span class="type">ssize_t</span> written = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; point &lt; POINTERS_PER_INODE &amp;&amp; length &gt; <span class="number">0</span>; point++)</span><br><span class="line">    &#123;</span><br><span class="line">        Block block;</span><br><span class="line">        <span class="built_in">memset</span>(block.data, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(node.direct[point] == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            node.direct[point] = fs_allocate_free_block(fs);</span><br><span class="line">            <span class="keyword">if</span>(node.direct[point] == <span class="number">0</span>) <span class="keyword">goto</span> last;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> assert(disk_read(fs-&gt;disk, node.direct[point], block.data) != DISK_FAILURE);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">ssize_t</span> remaining = BLOCK_SIZE - offset % BLOCK_SIZE;</span><br><span class="line">        <span class="type">const</span> <span class="type">ssize_t</span> copy_size = remaining &lt; length? remaining : length;</span><br><span class="line">        <span class="built_in">memcpy</span>(block.data + offset % BLOCK_SIZE, data + written, copy_size);</span><br><span class="line">        assert(disk_write(fs-&gt;disk, node.direct[point], block.data) != DISK_FAILURE);</span><br><span class="line">        length -= copy_size;</span><br><span class="line">        offset += copy_size;</span><br><span class="line">        written += copy_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        point -= POINTERS_PER_INODE;</span><br><span class="line">        assert(point &gt;= <span class="number">0</span>);</span><br><span class="line">        Block block;</span><br><span class="line">        <span class="built_in">memset</span>(block.data, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(node.indirect == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            assert(offset%BLOCK_SIZE == <span class="number">0</span>);</span><br><span class="line">            node.indirect = fs_allocate_free_block(fs);</span><br><span class="line">            <span class="keyword">if</span>(node.indirect == <span class="number">0</span>) <span class="keyword">goto</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> assert(disk_read(fs-&gt;disk, node.indirect, block.data) != DISK_FAILURE);</span><br><span class="line">        <span class="keyword">while</span>(length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Block data_block;</span><br><span class="line">            <span class="built_in">memset</span>(data_block.data, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">            <span class="keyword">if</span>(block.pointers[point] == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                block.pointers[point] = fs_allocate_free_block(fs);</span><br><span class="line">                <span class="keyword">if</span>(block.pointers[point] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> assert(disk_read(fs-&gt;disk, block.pointers[point], data_block.data) != DISK_FAILURE);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">ssize_t</span> remaining = BLOCK_SIZE - offset % BLOCK_SIZE;</span><br><span class="line">            <span class="type">const</span> <span class="type">ssize_t</span> copy_size = remaining &lt; length? remaining : length;</span><br><span class="line">            <span class="built_in">memcpy</span>(data_block.data + offset%BLOCK_SIZE, data + written, copy_size);     </span><br><span class="line">            assert(disk_write(fs-&gt;disk, block.pointers[point], data_block.data) != DISK_FAILURE);</span><br><span class="line">            point++;</span><br><span class="line">            length -= copy_size;</span><br><span class="line">            offset += copy_size;</span><br><span class="line">            written += copy_size;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(disk_write(fs-&gt;disk, node.indirect, block.data) != DISK_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">last:</span><br><span class="line">    node.size = offset &gt; node.size ? offset : node.size;</span><br><span class="line">    assert(fs_save_inode(fs, inode_number, &amp;node));</span><br><span class="line">    <span class="keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>参考信息：<a target="_blank" rel="noopener" href="https://www.51cto.com/article/603104.html">https://www.51cto.com/article/603104.html</a></p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ext2/">ext2</a></div><div class="post-share"><div class="social-share" data-image="/img/covers/9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/db&amp;%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/" title="redis"><img class="cover" src="/img/covers/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">redis</div></div><div class="info-2"><div class="info-item-1">redis安装和配置12345yum search all redis|grep redis # 列举相关redis包进行安装yum install redis hiredis hiredis-devel redis-doc.noarch# 通过man手册查看文档systemctl start redissystemctl status redisps -ef|grep redis  redis上手redis首先是一个强大的缓存服务器，比memcache强大很多，不仅仅支持多种数据结构（不像memcache 只能存储字符串）如字符串、list列表、set集合、map映射表等结构，还可以支持数据的持久化存储 （memcache只支持内存存储），经常被应用到高并发的服务器环境设计之中。 数据缓存功能1redis-cli 字符串操作123456SET key value [EX seconds] [PX milliseconds] [NX|XX]# NX不存在则创建，XX不存在则返回nilget key# 不存在返回nil，get只能用于字符串值INCR key#...</div></div></div></a><a class="pagination-related" href="/c++/net%E7%BD%91%E7%BB%9C/" title="网络"><img class="cover" src="/img/covers/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络</div></div><div class="info-2"><div class="info-item-1">TCP&#x2F;IP协议族 ARP：IP地址和物理地址的转换  12Type 0x800:ipopt 1:request	2:reply	3:	4:  arp -a查看arpcache ICMP：测试网络，实际上是IP协议的一部分，由每一个IP协议模块实现，包含8位type、8位code、16RCR和32位content 一般type只用到  Destination Unreachable Message  123456789Type 3Code  0 = net unreachable;  1 = host unreachable;  2 = protocol unreachable;  3 = port unreachable;  4 = fragmentation needed and DF set;  5 = source route failed.content unused   Redirect Message  1234567Type 5Code  0 = Redirect datagrams for the Network.  1 = Redirect...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">前导知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%84%E6%88%90-%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98"><span class="toc-number">1.1.</span> <span class="toc-text">磁盘组成(机械硬盘)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ext%E5%AE%B6%E6%97%8F"><span class="toc-number">2.</span> <span class="toc-text">ext家族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">组成：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">文件系统的完整结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode"><span class="toc-number">2.3.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">单文件系统：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-number">2.4.1.</span> <span class="toc-text">挂载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-SimpleFS"><span class="toc-number">3.</span> <span class="toc-text">A SimpleFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">测试：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">代码：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">磁盘模拟器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.2.</span> <span class="toc-text">文件系统</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Jerold</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>