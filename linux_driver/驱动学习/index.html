<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>驱动学习 | Jerold‘s PNote</title><meta name="author" content="Jerold"><meta name="copyright" content="Jerold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="驱动入门驱动是底层硬件和上层软件的桥梁 分类： 裸机程序：直接和硬件，寄存器打交道 Linux系统：基于linux驱动框架编程，统一接口，指dev下面的设备节点 驱动分类：  字符设备：串行顺序依次访问 网络设备：面向数据包的接发 块设备：按任意顺序访问  linux源码：www.kernel.org 半导体产商拉去linux源码，针对cpu进行适配，后下发给客户 linux源码目录：~&amp;#x2">
<meta property="og:type" content="article">
<meta property="og:title" content="驱动学习">
<meta property="og:url" content="http://example.com/linux_driver/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Jerold‘s PNote">
<meta property="og:description" content="驱动入门驱动是底层硬件和上层软件的桥梁 分类： 裸机程序：直接和硬件，寄存器打交道 Linux系统：基于linux驱动框架编程，统一接口，指dev下面的设备节点 驱动分类：  字符设备：串行顺序依次访问 网络设备：面向数据包的接发 块设备：按任意顺序访问  linux源码：www.kernel.org 半导体产商拉去linux源码，针对cpu进行适配，后下发给客户 linux源码目录：~&amp;#x2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/11.jpg">
<meta property="article:published_time" content="2025-08-23T16:40:06.000Z">
<meta property="article:modified_time" content="2025-08-23T16:40:06.000Z">
<meta property="article:author" content="Jerold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/11.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/linux_driver/%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '驱动学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/11.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jerold‘s PNote</span></a><a class="nav-page-title" href="/"><span class="site-name">驱动学习</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">驱动学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-23T16:40:06.000Z" title="发表于 2025-08-24 2025-08-24T00:40:06+08:00">2025-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-23T16:40:06.000Z" title="更新于 2025-08-24 2025-08-24T00:40:06+08:00">2025-08-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h2 id="驱动入门"><a href="#驱动入门" class="headerlink" title="驱动入门"></a>驱动入门</h2><p>驱动是底层硬件和上层软件的桥梁</p>
<p>分类：</p>
<p>裸机程序：直接和硬件，寄存器打交道</p>
<p>Linux系统：基于linux驱动框架编程，统一接口，指dev下面的设备节点</p>
<p>驱动分类：</p>
<ul>
<li>字符设备：串行顺序依次访问</li>
<li>网络设备：面向数据包的接发</li>
<li>块设备：按任意顺序访问</li>
</ul>
<p>linux源码：<a target="_blank" rel="noopener" href="http://www.kernel.org/">www.kernel.org</a></p>
<p>半导体产商拉去linux源码，针对cpu进行适配，后下发给客户</p>
<p>linux源码目录：~&#x2F;kernel&#x2F;kernel-5.10</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>架构相关目录，里面存放许多CPU架构，如arm，x86</td>
</tr>
<tr>
<td>block</td>
<td>存放块设备相关代码，比如硬盘，SD卡</td>
</tr>
<tr>
<td>crypto</td>
<td>存放加密算法目录</td>
</tr>
<tr>
<td>Documentation</td>
<td>存放官方linux内核文档</td>
</tr>
<tr>
<td>drivers</td>
<td>驱动目录，存放linux系统支持的硬件设备驱动源码</td>
</tr>
<tr>
<td>firmware</td>
<td>存放固件目录</td>
</tr>
<tr>
<td>fs</td>
<td>存放支持的文件系统代码目录</td>
</tr>
<tr>
<td>include</td>
<td>存放公共的头文件目录</td>
</tr>
<tr>
<td>init</td>
<td>存放linux内核启动初始化代码</td>
</tr>
<tr>
<td>ipc</td>
<td>存放进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>存放内核本身的代码文件</td>
</tr>
<tr>
<td>lib</td>
<td>存放库函数的文件夹</td>
</tr>
<tr>
<td>mm</td>
<td>存放内存管理的目录</td>
</tr>
<tr>
<td>net</td>
<td>存放网络相关代码，比如TCP&#x2F;IP协议栈</td>
</tr>
<tr>
<td>scripts</td>
<td>存放脚本相关代码</td>
</tr>
<tr>
<td>security</td>
<td>存放安全相关代码</td>
</tr>
<tr>
<td>sound</td>
<td>存放音频相关代码</td>
</tr>
<tr>
<td>tools</td>
<td>存放linux用到的工具文件夹</td>
</tr>
<tr>
<td>usr</td>
<td>和linux内核启动有关代码</td>
</tr>
<tr>
<td>virt</td>
<td>内核虚拟机相关代码</td>
</tr>
</tbody></table>
<h3 id="第一个驱动：helloworld"><a href="#第一个驱动：helloworld" class="headerlink" title="第一个驱动：helloworld"></a>第一个驱动：helloworld</h3><p>写驱动由几部分组成：</p>
<p>1、头文件：内核相关，必须有#include&lt;linux&#x2F;module.h&gt;和#include&lt;linux&#x2F;init&gt;</p>
<p>2、驱动加载函数，加载驱动时被内核自动调用</p>
<p>3、驱动卸载函数，卸载时自动调用</p>
<p>4、许可证声明，内核遵守GPL协议，可使用GPL，GPLv2</p>
<p>可选：</p>
<p>5、模块参数</p>
<p>6、作者和版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// helloworld drivers</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init&gt;</span><br><span class="line"></span><br><span class="line">// init函数必须int</span><br><span class="line">static int helloworld_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	// 内核里无法使用标准库</span><br><span class="line">	printk(&quot;helloworld\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void helloworld_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	printk(&quot;helloworld exit\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(helloworld_init);</span><br><span class="line">module_exit(helloworld_exit);</span><br><span class="line"></span><br><span class="line">MOULDE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;zzh&quot;);</span><br><span class="line">MODULE_VERSION(&quot;V1.0&quot;);</span><br></pre></td></tr></table></figure>

<p>编译linux驱动程序的两种方法：</p>
<p>1：将驱动放到内核的顶层目录的drivers中，随内核一起编译，烧写镜像</p>
<p>2：编译成内核模块，可以在系统运行时插入或者卸载，无需重启系统，后缀为.ko</p>
<p><strong>simple makefile</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += helloworld.o	# -m表示编译成模块</span><br><span class="line">KDIR = /home/linux-kernel/ #内核源码绝对路径</span><br><span class="line">PWD ?= $(shell pwd)		# makefile和源码路径</span><br><span class="line">all:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) modules #</span><br><span class="line">clean:</span><br><span class="line">	rm -f *.ko *.0 *.mod.o *.mod.c *.symvers *.order</span><br></pre></td></tr></table></figure>

<h3 id="第一种方法：将驱动编译内核模块"><a href="#第一种方法：将驱动编译内核模块" class="headerlink" title="第一种方法：将驱动编译内核模块"></a>第一种方法：将驱动编译内核模块</h3><p>1、创建makefile</p>
<p>2、写入上面makefile规则</p>
<p>3、编译内核源码并烧写</p>
<p>4、  可以在linux源码顶层目录的makefile设置这两个变量</p>
<p>export ARCH&#x3D;arm64</p>
<p>export CROSS_COMPILE&#x3D;交叉编译器的路径</p>
<p>5、make</p>
<h3 id="模块加载命令"><a href="#模块加载命令" class="headerlink" title="模块加载命令"></a>模块加载命令</h3><ul>
<li>insmod 模块名.ko：</li>
<li>modprobe 模块名.ko：加载内核模块时同时加载依赖的模块</li>
<li>rmmod 模块名.ko</li>
<li>lsmod或者cat &#x2F;proc&#x2F;modules</li>
<li>modinfo 模块名.ko：查看内核模块信息</li>
</ul>
<p>make menuconfig</p>
<p>在内核源码顶层目录输入命令可以打开图形</p>
<p><code>sudo apt-get install libncurses5-dev</code></p>
<p>操作：按空格选择配置状态：M, *, 不编译</p>
<p>[]：两种状态，编译进内核</p>
<p>&lt;&gt;：三种</p>
<p>() ：存放字符串或者15进制数</p>
<h3 id="与menuconfig相关的文件"><a href="#与menuconfig相关的文件" class="headerlink" title="与menuconfig相关的文件"></a>与menuconfig相关的文件</h3><p>makefile，config，Kconfig</p>
<p><strong>Kconfig</strong>：是图形化配置界面的源文件，make manuconfig实际读取arch&#x2F;$(ARCH)&#x2F;Kconfig</p>
<p><strong>config和.config</strong>：config在arch&#x2F;$(ARCH)&#x2F;configs目录下，.config在内核源码顶层目录下</p>
<p>使用.config的配置来编译内核，make manuconfig修改后的文件即.config文件，.config &gt; Kconfig</p>
<p>config是系统默认的配置文件，make xxx_deconfig会编译config成 <strong>.config</strong></p>
<h3 id="Kconfig语法"><a href="#Kconfig语法" class="headerlink" title="Kconfig语法"></a>Kconfig语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 主菜单标题，比如x86 4.19.232</span><br><span class="line">mainmenu &quot;Linux/$(ARCH)$(KERNELVERSION) Kernel Configuration&quot;</span><br><span class="line"># </span><br><span class="line">menu</span><br><span class="line">	config helloworld</span><br><span class="line">			bool/tristate/string &quot;hello world support&quot;</span><br><span class="line">			default y</span><br><span class="line">			help</span><br><span class="line">				hello world</span><br><span class="line">	menu &quot;yyy&quot;</span><br><span class="line">	...</span><br><span class="line">	endmenu</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>bool&#x2F;tristate&#x2F;string代表三种括号，default则是kconfig的默认配置，如果没有.config则会用这里的默认配置，help是帮助信息</p>
<p>生产.config变成CONFIG_helloworld</p>
<p><strong>依赖关系：</strong></p>
<p>A依赖B；A反向依赖B，即有A则有B</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config A</span><br><span class="line">		depends on B</span><br><span class="line">config A</span><br><span class="line">		select B</span><br></pre></td></tr></table></figure>

<p><strong>可选择项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">choice</span><br><span class="line"></span><br><span class="line">choice</span><br><span class="line">...</span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p><strong>注释：</strong></p>
<p>comment “xxx”</p>
<p>在图形化界面选项下面显示</p>
<p><strong>source：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;init/Kconfig&quot;</span><br></pre></td></tr></table></figure>

<p>读取另一个Kconfig文件</p>
<h3 id="第二种方法：将驱动编译进内核"><a href="#第二种方法：将驱动编译进内核" class="headerlink" title="第二种方法：将驱动编译进内核"></a>第二种方法：将驱动编译进内核</h3><p>1、</p>
<p>cd drivers &amp; cd char进去驱动目录和字符设备目录</p>
<p>mkdir helloworld创建添加的驱动目录</p>
<p>touch Kconfig makefile helloworld.c创建三个文件</p>
<p>2、</p>
<p><strong>Kconfig：</strong>（去上一级目录的Kconfig包含该文件 source hellowrold&#x2F;Kconfig）</p>
<p>去顶层目录进行make menuconfig生产.config文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config helloworld</span><br><span class="line">		bool &quot;helloworld support&quot;</span><br><span class="line">		default y</span><br><span class="line">		help</span><br><span class="line">				hellworld</span><br></pre></td></tr></table></figure>

<p>3、</p>
<p><strong>helloworld.c：</strong></p>
<p>4、</p>
<p><strong>makefile：</strong>在.config文件已经包含CONFIG_helloworld&#x3D;y变量</p>
<p>在上一级makefile添加关联：<code>obj-y += helloworld/</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_helloworld)	+= helloworld.o</span><br></pre></td></tr></table></figure>

<p>5、</p>
<p>build.sh里面<code>function build_kernel()</code>函数&#96;包含</p>
<p>使用默认的config文件生产.config，覆盖了现有的.config，使用当前的.config覆盖默认的config</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=$ARCH $KERNEL_DECONFIG $KERNEL_DEFONCIF_FRAMENT</span><br></pre></td></tr></table></figure>

<p>6、</p>
<p>.&#x2F;build.sh kernel</p>
<p>7、</p>
<p>烧写的dmesg</p>
<h3 id="驱动模块传参"><a href="#驱动模块传参" class="headerlink" title="驱动模块传参"></a>驱动模块传参</h3><p>1、让驱动程序更加灵活，兼容性更强，根据传参走不同流程</p>
<p>2、设置安全校验，防止驱动被盗用</p>
<p>不足：</p>
<p>1、复杂化</p>
<p>2、占用资源空间</p>
<p><strong>传递类型：</strong></p>
<ul>
<li>基本类型：moudle_param</li>
<li>数组：moudle_param_array</li>
<li>字符串：module_param_string</li>
</ul>
<p><img src="/./../pic/linux_driver/image-20250927230636600.png" alt="image-20250927230636600"></p>
<blockquote>
<p>参数的读写权限定义在：include&#x2F;linux&#x2F;stat.h&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;stat.h</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">#include &lt;linux/moduleparam.h&gt;</span><br><span class="line">static int a=0;</span><br><span class="line">static int array[5]=&#123;0&#125;;</span><br><span class="line">static int array_size;</span><br><span class="line">statc char str1[10]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">module_param(a, int, S_IRUGO);</span><br><span class="line">MODULE_PARAM_DESC(a, &quot;e.g a=1&quot;);</span><br><span class="line"></span><br><span class="line">module_param(array, int, &amp;array_size, S_IRUGO);</span><br><span class="line">MODULE_PARAM_DESC(array, &quot;e.g array=1,2,3&quot;);</span><br><span class="line"></span><br><span class="line">module_param(str, str1, sizeof(str1), S_IRUGO);</span><br><span class="line">MODULE_PARAM_DESC(str1, &quot;e.g str=hello&quot;);</span><br><span class="line"></span><br><span class="line">...在下面printk打印</span><br></pre></td></tr></table></figure>

<p>使用insmod hello.ko a&#x3D;1, array&#x3D;1,2,3 str&#x3D;hello后可以看到打印信息</p>
<p>使用modinfo可以看到desc信息</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>解决多模块依赖问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名)</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名)   // 只适用包含GPL许可的模块</span><br></pre></td></tr></table></figure>



<h3 id="系统如何运行驱动"><a href="#系统如何运行驱动" class="headerlink" title="系统如何运行驱动"></a>系统如何运行驱动</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MODULE</span><br><span class="line">#define module_init(x) __initcall(x)</span><br></pre></td></tr></table></figure>

<p>linux内核顶层的makefile定义了两个变量，决定编译进内核或模块的MODULE宏是否开启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KBUILD_CFLAGS_KERNEL :=</span><br><span class="line">KBUILD_CFLAGS_MODULE :=</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module_init   -----&gt;    __define_initcall(fn, id, __sec)</span><br><span class="line">static initcall_t __initcall_##fn##-d __used \</span><br><span class="line">    __attribute__((__section__(#__sec &quot;.innit&quot;))) = fn;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到最终声明了一个__initcall_hello_world6的函数指针变量，放到.initcall6.init段中</strong></p>
<p>内核驱动的module_init会按照编译的先后顺序放到.initcall6.init段中</p>
<p><strong>除了module_init，其他init函数原型都是调用__define_initcall，最不过优先级不一样，启动顺序不一样，这些init函数放在init.h文件</strong></p>
<p><img src="/./../pic/linux_driver/image-20250928011753106.png" alt="image-20250928011753106"></p>
<p>在inlcude&#x2F;asm-generic&#x2F;vmlinux.lds.h文件中的定义宏<strong>INIT_CALLS</strong></p>
<p>这个将**__initcall##level##__start<strong>关联到</strong>.initcall##level##.init<strong>和</strong>.initcall##level##s.init**段中，</p>
<p>可以看到代码中INIT_CALLS将<strong>段0到段7的内存区域按照顺序连接到一起</strong>，并且通过**__initcall##level##__start记录每个段的起始地址**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_CALLS_LEVEL(level)						\</span><br><span class="line">		__initcall##level##_start = .;				\</span><br><span class="line">		KEEP(*(.initcall##level##.init))			\</span><br><span class="line">		KEEP(*(.initcall##level##s.init))			\</span><br><span class="line"></span><br><span class="line">#define INIT_CALLS							\</span><br><span class="line">		__initcall_start = .;					\</span><br><span class="line">		KEEP(*(.initcallearly.init))				\</span><br><span class="line">		INIT_CALLS_LEVEL(0)					\</span><br><span class="line">		INIT_CALLS_LEVEL(1)					\</span><br><span class="line">		INIT_CALLS_LEVEL(2)					\</span><br><span class="line">		INIT_CALLS_LEVEL(3)					\</span><br><span class="line">		INIT_CALLS_LEVEL(4)					\</span><br><span class="line">		INIT_CALLS_LEVEL(5)					\</span><br><span class="line">		INIT_CALLS_LEVEL(rootfs)				\</span><br><span class="line">		INIT_CALLS_LEVEL(6)					\</span><br><span class="line">		INIT_CALLS_LEVEL(7)					\</span><br><span class="line">		__initcall_end = .;</span><br></pre></td></tr></table></figure>



<p>在init&#x2F;main.c文件中的一个<strong>static全局变量数组</strong>存放这上面每个段的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extern initcall_entry_t __initcall_start[];</span><br><span class="line">...</span><br><span class="line">static initcall_entry_t *initcall_levels[] __initdata = &#123;</span><br><span class="line">	__initcall0_start,</span><br><span class="line">	__initcall1_start,</span><br><span class="line">	__initcall2_start,</span><br><span class="line">	__initcall3_start,</span><br><span class="line">	__initcall4_start,</span><br><span class="line">	__initcall5_start,</span><br><span class="line">	__initcall6_start,</span><br><span class="line">	__initcall7_start,</span><br><span class="line">	__initcall_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上数组最终在<strong>do_initcalls</strong>被使用，函数的调用流程图</p>
<p>在main.c中内核调用第一个函数start_kernel，包含了许多模块的初始化函数，</p>
<p>在rest_init中调用了kernel_thread使用一个内核线程去执行，</p>
<p>最后在do_initcalls函数去for循环initcall_levels数组，从0开始，所以在代码里看到数字越小优先级越高，同一个level带s优先级低</p>
<p><img src="/./../pic/linux_driver/image-20250928014454402.png" alt="image-20250928014454402"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void __init do_initcall_level(int level, char *command_line)</span><br><span class="line">&#123;</span><br><span class="line">	initcall_entry_t *fn;</span><br><span class="line"></span><br><span class="line">	parse_args(initcall_level_names[level],</span><br><span class="line">		   command_line, __start___param,</span><br><span class="line">		   __stop___param - __start___param,</span><br><span class="line">		   level, level,</span><br><span class="line">		   NULL, ignore_unknown_bootoption);</span><br><span class="line"></span><br><span class="line">	do_trace_initcall_level(initcall_level_names[level]);</span><br><span class="line">	for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)</span><br><span class="line">		do_one_initcall(initcall_from_entry(fn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __init do_initcalls(void)</span><br><span class="line">&#123;</span><br><span class="line">	int level;</span><br><span class="line">	size_t len = saved_command_line_len + 1;</span><br><span class="line">	char *command_line;</span><br><span class="line"></span><br><span class="line">	command_line = kzalloc(len, GFP_KERNEL);</span><br><span class="line">	if (!command_line)</span><br><span class="line">		panic(&quot;%s: Failed to allocate %zu bytes\n&quot;, __func__, len);</span><br><span class="line"></span><br><span class="line">	for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++) &#123;</span><br><span class="line">		/* Parser modifies command_line, restore it each time */</span><br><span class="line">		strcpy(command_line, saved_command_line);</span><br><span class="line">		do_initcall_level(level, command_line);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(command_line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="字符设备基础"><a href="#字符设备基础" class="headerlink" title="字符设备基础"></a>字符设备基础</h2><h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>linux规定每一个字符设备或块设备都必须有一个专属的设备号——一个设备号分为主设备号和次设备号</p>
<p>主设备：表示某一类驱动，如USB驱动，声卡驱动</p>
<p>此设备：表示该类别的第几个设备</p>
<p>开发字符设备，要注册设备号，向系统告诉用的什么设备，才能向系统注册设备</p>
<p>在include&#x2F;linux&#x2F;types.h中，设备号其实是32位无符号整型，其中高12位为主设备号，低20位为次设备号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef u32 __kernel_dev_t;</span><br><span class="line">typedef __kernel_dev_t		dev_t;</span><br></pre></td></tr></table></figure>

<p>在include&#x2F;linux&#x2F;kdev.h中包含了设备号的操作方法宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define MINORBITS	20</span><br><span class="line">#define MINORMASK	((1U &lt;&lt; MINORBITS) - 1)</span><br><span class="line"></span><br><span class="line">#define MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="line">#define MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="line">#define MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span><br></pre></td></tr></table></figure>

<p>设备号分配：</p>
<ul>
<li>静态分配：开发人员指定非被系统占用的设备号：cat &#x2F;proc&#x2F;devices</li>
<li>动态分配：系统自动分配</li>
</ul>
<p>在include&#x2F;linux&#x2F;fs.h中定义了两个方法的分配函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//  设备号起始值  此设备号数量  设备名称</span><br><span class="line">//  成功返回0，失败小于0</span><br><span class="line">int register_chrdev_region(dev_t, unsigned, const char*)</span><br><span class="line">//  保存申请到的设备号  次设备号的起始地址，一般0   设备号数量  设备号名称  </span><br><span class="line">//  成功返回0，失败小于0</span><br><span class="line">int alloc_chrdev_region(dev_t*, unsigned, unsigned, const char*)</span><br><span class="line"></span><br><span class="line">unregister_chrdev_region(dev_t, unsigned)</span><br></pre></td></tr></table></figure>



<p>example</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/moudle.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/kdev_t.h&gt;</span><br><span class="line">#include &lt;linux/types.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">static int major = 0;</span><br><span class="line">static int minor = 0;</span><br><span class="line"></span><br><span class="line">module_param(major, int, S_IRUGO);</span><br><span class="line">module_param(minor, int, S_IRUGO);</span><br><span class="line"></span><br><span class="line">dev_t dev_num;</span><br><span class="line"></span><br><span class="line">static int _init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    if(major) &#123;</span><br><span class="line">    	dev_num=MKDEV(major,minor);</span><br><span class="line">    	ret=register_chrdev_region(deV_num,1,&quot;chardev_name&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	ret=alloc_chrdev_region(&amp;dev_num,0,1,&quot;alloc_name&quot;);</span><br><span class="line">    	major=MAJOR(dev_num);</span><br><span class="line">    	minor=MINOR(dev_num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void _exit(void)</span><br><span class="line">&#123;</span><br><span class="line">	unregister_chrdev_region(dev_num,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init();</span><br><span class="line">module_exit();</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;xxx&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><p>1、</p>
<p>在linux中使用cdev结构体描述一个字符设备，位于include&#x2F;linux&#x2F;cdev.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct cdev&#123;</span><br><span class="line">struct kobject kobj;</span><br><span class="line">struct module*owner;   //所属模块</span><br><span class="line">const struct file_operations*ops;  // 文件操作结构体，系统调用和驱动程序的桥梁</span><br><span class="line">struct list_head list;</span><br><span class="line">dev_t dev;  //设备号</span><br><span class="line">unsigned int count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、</p>
<p><strong>cdev_init</strong>初始化cdev结构体，建立cdev与ops的联系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void cdev_init(strcut cdev*cdev, const struct file_operation*fops)</span><br><span class="line">&#123;</span><br><span class="line">memset(cdev,0,sizeof(*cdev));</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;list);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops=fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、</p>
<p><strong>cdev_add</strong>向系统添加cdev结构体，向系统添加字符设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int cdev_add(struct cdev*p, dev_t dev, unsigned count)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line">	p-&gt;dev=dev;</span><br><span class="line">	p-&gt;count=count;</span><br><span class="line">	</span><br><span class="line">	error=kobj_map(cdev_map, dev, count, NULL,</span><br><span class="line">		exact_match, exact_lock, p);</span><br><span class="line">	if(error)</span><br><span class="line">		return error;</span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、</p>
<p><strong>cdev_del</strong>删除字符设备</p>
<h3 id="file-operations"><a href="#file-operations" class="headerlink" title="file_operations"></a>file_operations</h3><p>该结构体在include&#x2F;linux&#x2F;fs.h定义，使得应用层可以操作驱动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line">	struct module *owner;</span><br><span class="line">	fop_flags_t fop_flags;</span><br><span class="line">	loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line">	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">	int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,</span><br><span class="line">			unsigned int flags);</span><br><span class="line">	int (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">	__poll_t (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line">	int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">	int (*open) (struct inode *, struct file *);</span><br><span class="line">	int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line">	int (*release) (struct inode *, struct file *);</span><br><span class="line">	int (*fsync) (struct file *, loff_t, loff_t, int datasync);</span><br><span class="line">	int (*fasync) (int, struct file *, int);</span><br><span class="line">	int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line">	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</span><br><span class="line">	int (*check_flags)(int);</span><br><span class="line">	int (*flock) (struct file *, int, struct file_lock *);</span><br><span class="line">	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</span><br><span class="line">	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</span><br><span class="line">	void (*splice_eof)(struct file *file);</span><br><span class="line">	int (*setlease)(struct file *, int, struct file_lease **, void **);</span><br><span class="line">	long (*fallocate)(struct file *file, int mode, loff_t offset,</span><br><span class="line">			  loff_t len);</span><br><span class="line">	void (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">	unsigned (*mmap_capabilities)(struct file *);</span><br><span class="line">#endif</span><br><span class="line">	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,</span><br><span class="line">			loff_t, size_t, unsigned int);</span><br><span class="line">	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,</span><br><span class="line">				   struct file *file_out, loff_t pos_out,</span><br><span class="line">				   loff_t len, unsigned int remap_flags);</span><br><span class="line">	int (*fadvise)(struct file *, loff_t, loff_t, int);</span><br><span class="line">	int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);</span><br><span class="line">	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,</span><br><span class="line">				unsigned int poll_flags);</span><br><span class="line">	int (*mmap_prepare)(struct vm_area_desc *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>



<h3 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h3><p>通过ops操作设备节点文件就利用操作驱动，设备节点被创建在&#x2F;dev目录下</p>
<p>1：手动创建</p>
<p>mknod 设备节点名称 设备类型(字符设备c 块设备b) 主设备号 次设备号</p>
<p>2：在注册设备时自动创建</p>
<p>udev机制：udev是一个用户程序，根据根据设备驱动的状态来自动创建或者删除设备节点</p>
<p>mdev机制：在嵌入式中使用mdev，是udev的简化版本，在使用busybox创建根文件系统时自动创建mdev</p>
<blockquote>
<p>设备驱动  ——》 udev ——》 &#x2F;sys&#x2F;class&#x2F;xxx</p>
<p>​					——》 &#x2F;dev&#x2F;xxx设备节点</p>
<p>当设备驱动加载到os，会在sys&#x2F;class生成对应文件夹，udev自动响应，去这个文件夹找信息生成设备节点</p>
</blockquote>
<p><strong>create相关函数</strong></p>
<p>struct device *device_create(struct class *cls, struct device *parent, dev_t dev_num, void *drvdata, const char *fmt, …);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stuct class *class;</span><br><span class="line">struct devices *device;</span><br><span class="line"></span><br><span class="line">static int modulecdev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">class = class_create(THIS_MODULE,&quot;test&quot;);</span><br><span class="line">devices = device_create(class, NULL, dev_num, NULL, &quot;test&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void modulecdev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">devices_destoy(class, dev_num);</span><br><span class="line">class_destroy(class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户空间和内核空间的数据交换"><a href="#用户空间和内核空间的数据交换" class="headerlink" title="用户空间和内核空间的数据交换"></a>用户空间和内核空间的数据交换</h3><p>当我们在用户程序使用read和write时，实际借助了两个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">unsigned long copy_from_user(void*to, const void __user*from, usigned long n);</span><br><span class="line">unsigned long copy_to_user(void __user*to,cons void*from, usinged long n);</span><br></pre></td></tr></table></figure>

<h3 id="设备结构体"><a href="#设备结构体" class="headerlink" title="设备结构体"></a>设备结构体</h3><p>随时驱动变复杂，将描述驱动的全局变量包装到一个结构体中</p>
<p>使用文件私有数据保存指向设备结构体的指针，linux面向对象的思想</p>
<p>rk3568开发板对应的交叉编译器：linux源码目录&#x2F;prebuilts&#x2F;gcc</p>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>解决串口通信两两相联的痛点，有以下总线通讯：</p>
<h3 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h3><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p><strong>特点：</strong></p>
<ul>
<li>一主多从模式，只能有一个主机</li>
<li>串行同步数据：MOSI和SCK同时配合</li>
<li>包含4条线：SCK、MOSI、MISO、SS</li>
</ul>
<p>片选信号线SS：高电平有效</p>
<p>SCK包含4中采集方式：当SCK<strong>高电平</strong>有效，只有在<strong>上升沿</strong>或下降沿数据信号才有效；</p>
<p>读写数据：读数据前也要先写入地址</p>
<img src="./../pic/linux_driver/image-20250824152701090.png" alt="image-20250824152701090" style="zoom:50%;" />

<h3 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h3><p><strong>特点：</strong></p>
<ul>
<li><p>芯片与芯片之间的通信</p>
</li>
<li><p>一主多从模式，任何设备都能成为主设备</p>
</li>
<li><p>串口通信两线为发送和接送，而IIC为SCL和SDA：</p>
</li>
</ul>
<p><strong>通信的工作机制：</strong></p>
<p>SCL<strong>高电平</strong>为工作，<strong>低电平</strong>时休息：高低电平转换频率代表通信的速率：频率高，时延小</p>
<p>SDA<strong>高电平</strong>为1，<strong>低电平</strong>为逻辑0</p>
<p>数据传输的起始和结束表示：SCL都为高电平时，SDA<strong>高变低</strong>为起始位，<strong>低变高</strong>为结束位</p>
<p>数据传输的应答：主设备送完<strong>8位</strong>时，第9位<strong>SDA始终为0</strong>代表应答，否则代表无应答</p>
<p><img src="/./../pic/linux_driver/image-20250824011332942.png" alt="image-20250824011332942"></p>
<p><strong>寻址：</strong></p>
<p>当总线连接多个设备时如何寻址，从设备包含多个寄存器时如何寻址</p>
<p>第一组数据的前7位代表<strong>器件地址</strong>（手册寻找），后一位代表读写位，0写1读</p>
<p>第二组数组代表<strong>子地址</strong>——子地址一旦设定，下次再读写时可以不设置</p>
<p><strong>如何进行读写</strong></p>
<p>第一组数据最后一位0代表接下来的多组数据都是写入</p>
<p>如果读数据，第一组最后一位0写入第二组的子地址，然后再发一次起始位S和第一组数据（器件地址+1）</p>
<p><img src="/./../pic/linux_driver/image-20250824013445116.png" alt="image-20250824013445116"></p>
<p><strong>预留器件地址：</strong></p>
<p><img src="/./../pic/linux_driver/image-20250824013648619.png" alt="image-20250824013648619"></p>
<h3 id="CAN——ctl-area-net"><a href="#CAN——ctl-area-net" class="headerlink" title="CAN——ctl area net"></a>CAN——ctl area net</h3><p><strong>通讯原理：</strong></p>
<p>需要专门CAN收发器：用于将1&#x2F;0的普通信号转换为差分信号：用两根线的电压差，如压差为0表示逻辑1</p>
<p>差分信号：通过双绞线缠绕，抗干扰能力强，只有一条时某点收到干扰电平发生<strong>跳变</strong>，两条线收到干扰压差不变；所以常规通讯通常10米，CAN信号可以传输1000米</p>
<h2 id="ioctl接口"><a href="#ioctl接口" class="headerlink" title="ioctl接口"></a>ioctl接口</h2><p>除了在应用层对设备进行读写数据之外，针对串口设备，驱动层还需要提供对串口波特率、奇偶校验位、终止位的设置，这些配置信息需要从应用层传递一些基本数据，仅仅是数据类型不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line">int ioctl(int fd, unsigned long request, ...);</span><br><span class="line">@fd：指定的设备</span><br><span class="line">@cmd：驱动层的命令和应用层的命令要统一封装</span><br><span class="line">失败返回-1，设置error</span><br></pre></td></tr></table></figure>

<p>内核原型函数为unlocked_ioctl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long (*unlocked_ioctl)(struct file*, unsigned int, unsinged long);</span><br><span class="line">第三个参数为用户空间传递的数据</span><br></pre></td></tr></table></figure>

<p><img src="/./../pic/linux_driver/image-20251012233531564.png" alt="image-20251012233531564"></p>
<p><strong>cmd解析：</strong></p>
<p>有效利用32位，分配四块部分：</p>
<p><img src="/./../pic/linux_driver/image-20251012233601291.png" alt="image-20251012233601291"></p>
<p><strong>封装命令：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************</span></span><br><span class="line"><span class="comment">*type ：设备类型</span></span><br><span class="line"><span class="comment">*nr  ：命令序号</span></span><br><span class="line"><span class="comment">*size ：用户传递的数据类型(int ,char ,struct name ..)</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line"><span class="comment">/* used to create numbers */</span></span><br><span class="line">_IO(type,nr)           :没有数据传递的命令</span><br><span class="line">_IOR(type,nr,datatype) :从驱动中读取数据</span><br><span class="line">_IOW(type,nr,datatype) :向驱动中写入数据</span><br><span class="line">_IOWR(type,nr,datatype) :双向传送</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">_IOC_NONE              :值为<span class="number">0</span>,无数据传输</span><br><span class="line">_IOC_READ              :值为<span class="number">1</span>,从设备驱动读取数据</span><br><span class="line">_IOC_WRITE             :值为<span class="number">2</span>,向设备驱动写入数据</span><br><span class="line">_IOC_READ|_IOC_WRITE   :双向数据传送</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"><span class="comment">/* used to decode ioctl numbers.. */</span></span><br><span class="line">_IOC_DIR(cmd)          :从命令中提取方向</span><br><span class="line">_IOC_TYPE(cmd)         :从命令中提取设备类型</span><br><span class="line">_IOC_NR(cmd)           :从命令中提取序号</span><br><span class="line">_IOC_SIZE(cmd)         :从命令中提取数据大小</span><br></pre></td></tr></table></figure>

<p>举例使用：</p>
<p>通过定义命令宏，使用上面内核封装好的宏，并给序列号</p>
<p>使用<code>_IOC_DIR</code>来解析方向，再使用access_ok(type, addr, size)来判断用户层传递的内存地址是否合法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Doucumentation/ioctl/ioctl-number.txt</span><br><span class="line">&#x27;k&#x27;	00-0F	linux/spi/spidev.h	conflict!</span><br><span class="line">&#x27;k&#x27;	00-05	video/kyro.h		conflict!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// pwm.h</span><br><span class="line">#ifndef _PWM_H</span><br><span class="line">#define _PWM_H</span><br><span class="line">#define DEV_FIFO_TYPE		&#x27;k&#x27;</span><br><span class="line">#define	DEV_FIFO_CLEAN		_IO(DEV_FIFO_TYPE,0)</span><br><span class="line">#define	DEV_FIFO_GETVALUE	_IOR(DEV_FIFO_TYPE,1,int)</span><br><span class="line">#define	DEV_FIFO_SETVALUE	_IOW(DEV_FIFO_TYPE,2,int)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//hello_ioctl.h</span><br><span class="line">...</span><br><span class="line">static int knum=99;</span><br><span class="line">long hello_ioctl(struct*filep, unsinged int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	long err,ret;</span><br><span class="line">	void __user*argp=(void __user*)arg;</span><br><span class="line">	int __user*p=argp;</span><br><span class="line">	</span><br><span class="line">	if(_IOC_TYPE(cmd)!=DEV_FIFO_TYPE) &#123;</span><br><span class="line">		pr_err(&quot;cmd %u,bad magic 0x%x/ 0x%x.\n&quot;,cmd,_IOC_TYPE(cmd),DEV_FIFO_TYPE);</span><br><span class="line">		return -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	if(_IOC_DIR(cmd)&amp;_IOC_READ)</span><br><span class="line">		ret=!access_ok(VERIFY_WRITE,(void __user*)arg,_IOC_SIZE(cmd));</span><br><span class="line">	else if(_IOC_DIR(cmd)&amp;_IOC_WRITE)</span><br><span class="line">		ret=!access_ok(VERIFY_READ,(void _user*)arg,_IOC_SIZE(cmd));</span><br><span class="line">	if(ret) &#123;</span><br><span class="line">		pr_err(&quot;bad access %ld.\n&quot;,ret);</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	switch(cmd)</span><br><span class="line">	&#123;</span><br><span class="line">		case DEV_FIFO_CLEAN:</span><br><span class="line">			printk(&quot;DEV_FIFO_CLEAN\n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		case DEV_FIFO_GETVALUE:</span><br><span class="line">			err=put_user(knum,p);</span><br><span class="line">			printk();</span><br><span class="line">			break;</span><br><span class="line">		case DEV_FIFO_SETVALUE:</span><br><span class="line">			err=get_user(knum,p);</span><br><span class="line">			printk();</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			return -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br><span class="line">static strcut file_operations hello_ops=&#123;</span><br><span class="line">	...</span><br><span class="line">	.unlocked_ioctl=hello_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// test.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#inlcude &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &quot;pwm.h&quot;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">int fd, len, num;</span><br><span class="line">fd=open(&quot;/dev/hellodev&quot;, O_RDWR);</span><br><span class="line">if(fd&lt;0) &#123;</span><br><span class="line">	perror(&quot;open faile\n&quot;);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">ioctl(fd, DEV_FIFO_CLEAN);</span><br><span class="line">ioctl(fd, DEV_FIFO_GETVALUE, &amp;num);</span><br><span class="line">num=77;</span><br><span class="line">ioctl(fd, DEV_FIFO_SETVALUE, &amp;num);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="pinctrl和GPIO子系统"><a href="#pinctrl和GPIO子系统" class="headerlink" title="pinctrl和GPIO子系统"></a>pinctrl和GPIO子系统</h2><h3 id="pinctrl"><a href="#pinctrl" class="headerlink" title="pinctrl"></a>pinctrl</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h4><p>pintctl依赖于设备树，pinctrl是指引脚管理系统，它可以设置引脚的复用模式（例如GPIO、串口、网口）和电气属性。pinctrl子系统可以把某一个外设用到的管脚pin放在同一个pin controller节点下面，方便引脚的管理和设置。</p>
<blockquote>
<p>这些定义在pin controller节点，Linux 源码 &#x2F;Documentation&#x2F;devicetree&#x2F;bindings 下的 txt 文档查看soc厂商的pin controller 的节点里面的属性</p>
</blockquote>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl-names = &quot;default&quot;，&quot;wake up&quot;;</span><br><span class="line">//定义设备的状态，可以有多个状态，default 为状态 0，wake up 为状态 1</span><br><span class="line"></span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">//第 0 个状态（pinctrl-0）所对应的引脚配置，也就是 default 状态对应的引脚在 pin controller 里面定义好的节点，即 pinctrl_hog_1 里面的管脚配置</span><br><span class="line">pinctrl-1 = &lt;&amp;pinctrl_hog_2&gt;;//第 1 个状态(pinctrl-1)所对应的引脚配置，也就是 wake up 状态对应的引脚在 pin controller 里面定义好的节点 ，即pinctrl_hog_2 里面的管脚配置</span><br></pre></td></tr></table></figure>

<h4 id="复用模式："><a href="#复用模式：" class="headerlink" title="复用模式："></a><strong>复用模式：</strong></h4><p>引脚复用模式（Pin Multiplexing）是指<strong>微控制器（MCU）或处理器的单个物理引脚</strong>，通过软件配置寄存器，切换为不同的内置硬件功能，以实现串口、SPI、I2C、ADC 等复杂外设功能，而非仅作为普通的 GPIO（通用输入输出）引脚使用。</p>
<p>比如一个引脚，默认是普通 GPIO（可控制高低电平），配置后可变成 UART 串口的接收端（RX），或 SPI 的时钟线（SCK）。</p>
<p>一个引脚可能的复用功能包括：</p>
<ul>
<li>基础功能：GPIO 输入 &#x2F; 输出</li>
<li>通信功能：UART（RX&#x2F;TX）、SPI（SCK&#x2F;MOSI&#x2F;MISO）、I2C（SDA&#x2F;SCL）</li>
<li>模拟功能：ADC（模拟信号输入）、DAC（模拟信号输出）</li>
<li>控制功能：PWM（脉冲宽度调制）、定时器捕获</li>
</ul>
<h4 id="如何配置引脚复用？"><a href="#如何配置引脚复用？" class="headerlink" title="如何配置引脚复用？"></a>如何配置引脚复用？</h4><p><strong>一、文档查询</strong></p>
<ul>
<li><p>查阅 RK3588 官方数据手册（Datasheet）和引脚复用手册（Pin Multiplexing Guide），明确目标引脚的 <strong>引脚编号（如 GPIO0_A0）</strong> 及支持的复用功能（如 UART、SPI、PWM 等）。</p>
</li>
<li><p>《RK3588 Pin Multiplexing Manual》：确认引脚的 <strong>电气特性</strong>（如电压域、驱动能力），确保与外设需求匹配（例如 I2C 引脚需兼容 3.3V 电平）。</p>
</li>
</ul>
<p><strong>二、硬件电路确定</strong></p>
<ul>
<li><strong>外设匹配</strong><ul>
<li>若复用为通信接口（如 I2C、SPI），需确保外设电路符合复用功能的电气要求：<ul>
<li>I2C 引脚需外接上拉电阻（通常 4.7kΩ）。</li>
<li>高速接口（如 SPI）需注意阻抗匹配和走线长度。</li>
</ul>
</li>
<li>若复用为模拟功能（如 ADC），需避免引脚连接数字电路干扰。</li>
</ul>
</li>
<li><strong>电源与接地</strong><ul>
<li>确认引脚所属电压域（如 3.3V 或 1.8V）与外设供电一致，避免电平不匹配导致损坏。</li>
</ul>
</li>
</ul>
<p><strong>三、设备树配置</strong></p>
<ol>
<li><p><strong>定位设备树文件</strong></p>
<ul>
<li>核心设备树：<code>rk3588.dtsi</code>（定义芯片级引脚复用模板）。</li>
<li>板级设备树：如<code>rk3588-evb.dts</code>（针对具体开发板的配置，继承自<code>rk3588.dtsi</code>）。</li>
<li>推荐在板级设备树中修改（避免直接修改核心文件，便于维护）。</li>
</ul>
</li>
<li><p><strong>配置 pinctrl 节点</strong></p>
<ul>
<li><p>RK3588 通过<code>pinctrl</code>子系统管理引脚复用，需定义功能对应的引脚组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 在板级设备树中添加 */</span><br><span class="line">&amp;pinctrl &#123;</span><br><span class="line">    /* 定义I2C3的引脚组，命名自定义（如i2c3_pins） */</span><br><span class="line">    i2c3_pins: i2c3-0 &#123;</span><br><span class="line">        /* 配置引脚复用功能：GPIO1_B2 -&gt; I2C3_SDA，GPIO1_B3 -&gt; I2C3_SCL */</span><br><span class="line">        rockchip,pins = &lt;</span><br><span class="line">            1 RK_PB2 2 &amp;pcfg_pull_up;  /* 1:GPIO1组，PB2:引脚，2:I2C3_SDA功能，上拉 */</span><br><span class="line">            1 RK_PB3 2 &amp;pcfg_pull_up;  /* 1:GPIO1组，PB3:引脚，2:I2C3_SCL功能，上拉 */</span><br><span class="line">        &gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><code>1 RK_PB2</code>：表示 GPIO1 组的 B2 引脚（对应物理引脚编号）。</li>
<li><code>2</code>：功能编号（需与文档中 I2C3_SDA 的功能码一致）。</li>
<li><code>&amp;pcfg_pull_up</code>：引脚电气配置（上拉，其他可选下拉、浮空等）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>绑定外设节点</strong></p>
<ul>
<li><p>将定义的引脚组关联到对应的外设控制器节点（如 I2C3 控制器）：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c3</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 使能I2C3控制器 */</span></span><br><span class="line">    <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span>  <span class="comment">/* 引脚组名称 */</span></span><br><span class="line">    pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;i2c3_pins</span>&gt;</span><span class="punctuation">;</span>   <span class="comment">/* 绑定上述定义的i2c3_pins */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 可添加外设设备节点（如传感器） */</span></span><br><span class="line">    <span class="title class_">sensor@48</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;xxx,sensor&quot;</span><span class="punctuation">;</span></span><br><span class="line">        <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x48</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">    <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>四、注意事项</strong></p>
<ol>
<li><strong>功能码匹配</strong>：不同复用功能对应唯一的功能码（如 I2C3_SDA 可能对应<code>2</code>），需严格参考官方文档。</li>
<li><strong>电气配置</strong>：根据外设需求设置引脚的上下拉、驱动强度（通过<code>pcfg_xxx</code>配置）。</li>
<li><strong>热插拔限制</strong>：部分引脚复用后不支持动态切换，需重启生效。</li>
</ol>
<hr>
<h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>当我们使用pinctrl子系统将我们的引脚设置为GPIO复用时，我们就要用GPIO子系统来操作GPIO，GPIO子系统是用于GPIO驱动的，用于设置GPIO引脚的配置（高低电平，输入输出等等）。</p>
<table>
<thead>
<tr>
<th>函数类别</th>
<th>函数原型</th>
<th>参数说明</th>
<th>返回值 &#x2F; 功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>gpio_request</strong></td>
<td><code>int gpio_request(unsigned gpio, const char *label)</code></td>
<td>- <code>gpio</code>：要申请的 GPIO 标号，可通过 <code>of_get_named_gpio</code> 从设备树获取- <code>label</code>：为 GPIO 设置的名字</td>
<td>返回 0 表示申请成功，其他值表示申请失败；功能是申请一个 GPIO 管脚</td>
</tr>
<tr>
<td><strong>gpio_free</strong></td>
<td><code>void gpio_free(unsigned gpio)</code></td>
<td>- <code>gpio</code>：要释放的 GPIO 标号</td>
<td>无返回值；功能是释放不再使用的 GPIO 管脚</td>
</tr>
<tr>
<td><strong>gpio_direction_input</strong></td>
<td><code>int gpio_direction_input(unsigned gpio)</code></td>
<td>- <code>gpio</code>：要设置为输入的 GPIO 标号</td>
<td>返回 0 表示设置成功，负值表示设置失败；功能是将某个 GPIO 设置为输入模式</td>
</tr>
<tr>
<td><strong>gpio_direction_output</strong></td>
<td><code>int gpio_direction_output(unsigned gpio, int value)</code></td>
<td>- <code>gpio</code>：要设置为输出的 GPIO 标号- <code>value</code>：GPIO 默认输出值（0 或 1）</td>
<td>返回 0 表示设置成功，负值表示设置失败；功能是将某个 GPIO 设置为输出模式，并设置默认输出值</td>
</tr>
<tr>
<td><strong>gpio_get_value</strong></td>
<td><code>int __gpio_get_value(unsigned gpio)</code></td>
<td>- <code>gpio</code>：要获取值的 GPIO 标号</td>
<td>成功返回 GPIO 的值（0 或 1），失败返回负值；功能是获取某个 GPIO 的电平值</td>
</tr>
<tr>
<td><strong>gpio_set_value</strong></td>
<td><code>void __gpio_set_value(unsigned gpio, int value)</code></td>
<td>- <code>gpio</code>：要设置值的 GPIO 标号- <code>value</code>：要设置的电平值（0 或 1）</td>
<td>无返回值；功能是设置某个 GPIO 的电平值</td>
</tr>
</tbody></table>
<ol>
<li><strong>引脚导出与注销</strong><ul>
<li><code>gpio_export(int gpio)</code>：将指定 GPIO 编号导出到用户空间（如<code>/sys/class/gpio/gpioXX</code>）。</li>
<li><code>gpio_unexport(int gpio)</code>：注销已导出的 GPIO。</li>
</ul>
</li>
<li><strong>方向配置</strong><ul>
<li><code>gpio_direction_input(int gpio)</code>：设置 GPIO 为输入模式。</li>
<li><code>gpio_direction_output(int gpio, int value)</code>：设置 GPIO 为输出模式，并初始化电平（<code>value</code>为 0 或 1）。</li>
</ul>
</li>
<li><strong>电平读写</strong><ul>
<li><code>gpio_get_value(int gpio)</code>：读取输入 GPIO 的电平（返回 0 或 1）。</li>
<li><code>gpio_set_value(int gpio, int value)</code>：设置输出 GPIO 的电平（0 为低，1 为高）。</li>
</ul>
</li>
<li><strong>中断配置（边沿检测）</strong><ul>
<li><code>gpio_set_debounce(int gpio, unsigned int debounce)</code>：设置防抖时间（毫秒）。</li>
<li><code>gpio_request_irq(int gpio, irq_handler_t handler, unsigned long flags, const char *name, void *dev)</code>：申请 GPIO 中断，注册中断处理函数。</li>
</ul>
</li>
</ol>
<h2 id="EDID"><a href="#EDID" class="headerlink" title="EDID"></a>EDID</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>EDID 是显示器给主机发的 “能力说明书”</strong>，核心是告诉主机 “我能接收什么格式的视频信号”，避免主机发一个显示器处理不了的信号（比如黑屏、画面撕裂）。</p>
<p>本质是显示器内部一个小存储芯片（通常是 EEPROM）里的二进制数据。</p>
<p>EDID 里包含 3 类关键信息:</p>
<ol>
<li><strong>基本信息</strong>：显示器品牌、型号、出厂日期（比如 “Dell U2723QE”）；</li>
<li><strong>显示能力</strong>：支持的分辨率（1080P&#x2F;2K&#x2F;4K）、刷新率（60Hz&#x2F;144Hz）、色域（sRGB&#x2F;DCI-P3）；</li>
<li><strong>时序参数</strong>：这是核心，决定 “视频信号怎么传、显示器怎么扫”</li>
</ol>
<h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><p>时序的本质是 <strong>“主机发信号的节奏” 和 “显示器扫画面的节奏” 的匹配规则</strong>。</p>
<blockquote>
<p>显示器怎么把 “1920x1080” 的画面显示出来？</p>
</blockquote>
<p>是一次性把所有像素怼到屏幕上，而是像 “看书一行一行扫”，先扫第一行所有像素，再扫第二行，直到扫完最后一行（这叫 “逐行扫描”）；扫完一整屏（一帧）后，再从头开始扫下一帧，反复循环。</p>
<p>时序参数就是规定 “扫一行 &#x2F; 一帧的具体时间分配”，分为 <strong>水平时序</strong>（扫一行的节奏）和 <strong>垂直时序</strong>（扫一帧的节奏），我们用最常见的 “1920x1080@60Hz” 为例拆解（60Hz 指每秒扫 60 帧画面）。</p>
<p><strong>1、水平时序</strong></p>
<p>1920x1080 的 “1920” 就是 “一行有 1920 个有效像素”。但主机发信号时，<strong>一行的总像素数不是 1920，而是比 1920 多</strong>—— 因为扫到行尾后，显示器的 “扫描电子枪”（或液晶驱动电路）需要时间 “从右回到左”，准备扫下一行，这个 “回位时间” 需要专门的 “同步信号” 来控制。</p>
<p>水平时序的核心参数（以 1920x1080@60Hz 为例）：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>通俗解释</th>
<th>1920x1080@60Hz 典型值</th>
<th>为什么需要这个参数？</th>
</tr>
</thead>
<tbody><tr>
<td>水平有效像素</td>
<td>一行中能显示画面的像素数（左到右的有效画面）</td>
<td>1920</td>
<td>决定 “一行画面有多宽”，比如 1920 就是 1080P 的宽度。</td>
</tr>
<tr>
<td>水平同步前沿（HSYNC Front Porch）</td>
<td>扫完有效像素后，先等一小段时间再发 “回位信号”</td>
<td>88</td>
<td>给显示器电路 “反应时间”，避免刚扫完有效像素就急着回位，导致画面边缘错位。</td>
</tr>
<tr>
<td>水平同步脉冲宽度</td>
<td>发 “回位信号” 的时间（告诉显示器 “该回左了”）</td>
<td>44</td>
<td>明确告诉显示器 “现在开始回位”，这个信号必须稳定，不然显示器不知道啥时候回左。</td>
</tr>
<tr>
<td>水平同步后沿（HSYNC Back Porch）</td>
<td>回位到行头后，再等一小段时间才扫下一行有效像素</td>
<td>148</td>
<td>给显示器 “准备时间”，确保回位到准确的行头位置，再开始扫下一行，避免画面偏移。</td>
</tr>
<tr>
<td>水平总像素</td>
<td>一行的总时间对应的像素数（有效 + 同步相关）</td>
<td>1920+88+44+148&#x3D;2200</td>
<td>决定 “一行的总时长”，进而影响刷新率（总像素越少，一行越快，帧率能更高）。</td>
</tr>
</tbody></table>
<p>简单说：水平时序的逻辑是 ——<strong>扫有效像素（1920）→ 等一下（前沿 88）→ 发回位信号（脉冲 44）→ 再等一下（后沿 148）→ 扫下一行</strong>。</p>
<p><strong>2、垂直时序（一帧画面的 “扫描节奏”）</strong></p>
<p>1920x1080 的 “1080” 就是 “一帧有 1080 个有效行”（能显示画面的行数）。和水平类似，扫完一帧后，显示器需要时间 “从下回到上”，准备扫下一帧，这也需要垂直同步信号控制。</p>
<p>垂直时序的核心参数（以 1920x1080@60Hz 为例）：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>通俗解释</th>
<th>1920x1080@60Hz 典型值</th>
<th>为什么需要这个参数？</th>
</tr>
</thead>
<tbody><tr>
<td>垂直有效行</td>
<td>一帧中能显示画面的行数（上到下的有效画面）</td>
<td>1080</td>
<td>决定 “一帧画面有多高”，比如 1080 就是 1080P 的高度。</td>
</tr>
<tr>
<td>垂直同步前沿（VSYNC Front Porch）</td>
<td>扫完有效行后，先等一小段时间再发 “回位信号”</td>
<td>4</td>
<td>给显示器电路 “反应时间”，避免刚扫完一帧就急着回位，导致画面底部错位。</td>
</tr>
<tr>
<td>垂直同步脉冲宽度</td>
<td>发 “回位信号” 的时间（告诉显示器 “该回上了”）</td>
<td>5</td>
<td>明确告诉显示器 “现在开始回位到顶部”，信号稳定才能保证回位准确。</td>
</tr>
<tr>
<td>垂直同步后沿（VSYNC Back Porch）</td>
<td>回位到顶部后，再等一小段时间才扫下一帧有效行</td>
<td>36</td>
<td>给显示器 “准备时间”，确保回位到准确的顶部位置，再开始扫下一帧，避免画面上下偏移。</td>
</tr>
<tr>
<td>垂直总行数</td>
<td>一帧的总时间对应的行数（有效 + 同步相关）</td>
<td>1080+4+5+36&#x3D;1125</td>
<td>决定 “一帧的总时长”，进而影响刷新率（总行数越少，一帧越快，帧率越高）。</td>
</tr>
</tbody></table>
<p>简单说：垂直时序的逻辑是 ——<strong>扫有效行（1080）→ 等一下（前沿 4）→ 发回位信号（脉冲 5）→ 再等一下（后沿 36）→ 扫下一帧</strong>。</p>
<p><strong>3、刷新率</strong></p>
<p>核心是 “主机发信号的时钟频率”。EDID 里要写清楚时序参数，主机通过该参数计算发送多快速度的信号，与显示器正确匹配</p>
<p>以 1920x1080@60Hz 为例：</p>
<ul>
<li>水平总像素 &#x3D; 2200，垂直总行数 &#x3D; 1125，所以一帧的总像素数 &#x3D; 2200×1125&#x3D;2,475,000；</li>
<li>要达到 60Hz（每秒 60 帧），主机需要每秒发 2,475,000×60&#x3D;148,500,000 个像素信号，这就是 “像素时钟频率”（148.5MHz）；</li>
<li>显示器的硬件（比如驱动板、面板）必须支持这个 148.5MHz 的时钟频率，才能跟上主机的信号节奏 —— 如果显示器只能支持 100MHz，那 1080P@60Hz 就用不了，只能降刷新率（比如 50Hz，此时像素时钟会降低）。</li>
</ul>
<p>「1920×1080@60Hz」显示模式为例，方便直观参考。</p>
<table>
<thead>
<tr>
<th>字节位置</th>
<th>参数大类</th>
<th>参数名称</th>
<th>核心含义</th>
<th>单位</th>
<th>典型值（1920×1080@60Hz）</th>
</tr>
</thead>
<tbody><tr>
<td>1-2</td>
<td>像素时钟</td>
<td>Pixel Clock</td>
<td>显示设备每秒处理的总像素数，是分辨率、刷新率计算的基础</td>
<td>10kHz（需 ×10）</td>
<td>字节值<code>0x5C 0x02</code>（对应 148.5MHz）</td>
</tr>
<tr>
<td>3-4</td>
<td>水平时序</td>
<td>Horizontal Active Pixels</td>
<td>画面水平方向实际显示的有效像素数（即横向分辨率）</td>
<td>像素</td>
<td>字节值<code>0x07 0x80</code>（对应 1920）</td>
</tr>
<tr>
<td>5</td>
<td>水平时序</td>
<td>Horizontal Front Porch</td>
<td>水平有效像素后，到同步脉冲前的空白像素段（用于信号稳定）</td>
<td>像素</td>
<td>148</td>
</tr>
<tr>
<td>6</td>
<td>水平时序</td>
<td>Horizontal Sync Pulse</td>
<td>触发显示设备 “换行” 的同步信号像素段</td>
<td>像素</td>
<td>44</td>
</tr>
<tr>
<td>7</td>
<td>水平时序</td>
<td>Horizontal Back Porch</td>
<td>水平同步脉冲后，到下一行有效像素前的空白像素段（用于信号稳定）</td>
<td>像素</td>
<td>148</td>
</tr>
<tr>
<td>8-9</td>
<td>垂直时序</td>
<td>Vertical Active Pixels</td>
<td>画面垂直方向实际显示的有效行数（即纵向分辨率）</td>
<td>行</td>
<td>字节值<code>0x04 0x38</code>（对应 1080）</td>
</tr>
<tr>
<td>10</td>
<td>垂直时序</td>
<td>Vertical Front Porch</td>
<td>垂直有效行后，到同步脉冲前的空白行数</td>
<td>行</td>
<td>3</td>
</tr>
<tr>
<td>11</td>
<td>垂直时序</td>
<td>Vertical Sync Pulse</td>
<td>触发显示设备 “换帧” 的同步信号行数</td>
<td>行</td>
<td>3</td>
</tr>
<tr>
<td>12</td>
<td>垂直时序</td>
<td>Vertical Back Porch</td>
<td>垂直同步脉冲后，到下一列有效行前的空白行数</td>
<td>行</td>
<td>32</td>
</tr>
<tr>
<td>13</td>
<td>时序控制</td>
<td>Timing Type</td>
<td>定义显示模式（如扫描方式、同步极性），<code>0x80</code>为当前主流的 “非隔行扫描”</td>
<td>无（标志位）</td>
<td>0x80（非隔行扫描）</td>
</tr>
<tr>
<td>14-15</td>
<td>物理尺寸</td>
<td>Horizontal Size</td>
<td>显示设备的物理宽度</td>
<td>0.1cm</td>
<td>字节值<code>0x68 0x00</code>（对应 108cm，即 43 英寸屏）</td>
</tr>
<tr>
<td>16-17</td>
<td>物理尺寸</td>
<td>Vertical Size</td>
<td>显示设备的物理高度</td>
<td>0.1cm</td>
<td>字节值<code>0x3C 0x00</code>（对应 60cm）</td>
</tr>
<tr>
<td>18</td>
<td>有效性标志</td>
<td>Timing Block Flag</td>
<td>标识该时序块是否有效，<code>0x00</code>为无效，<code>0x01</code>及以上为有效</td>
<td>无（标志位）</td>
<td>0x01（有效时序块）</td>
</tr>
</tbody></table>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>本质是 <strong>“解决显示器的物理延迟和信号稳定性问题”</strong></p>
<p><strong>1：画面边缘 “切角” 或 “错位”</strong></p>
<p>如果没有 “同步前沿 &#x2F; 后沿” 的等待时间，显示器刚扫完一行有效像素，就立刻回位，电路反应不过来，会导致 “行尾的像素还没显示完就开始回位”，画面右边会被切掉一块；同理，回位到行头后不等，直接扫下一行，会导致 “行头的像素显示到上一行的末尾”，画面整体左移、错位。</p>
<p><strong>2：画面 “撕裂”（最常见的不兼容现象）</strong></p>
<p>如果主机发信号的节奏和显示器扫画面的节奏不匹配（比如主机发得快，显示器扫得慢），就会出现 “上半帧是前一帧的画面，下半帧是后一帧的画面”，中间有一条明显的撕裂线。</p>
<p>时序参数的作用就是 “强制同步”：主机必须按照 EDID 里的时序发信号，显示器按照时序扫画面，两者节奏完全对齐，就不会撕裂。</p>
<p><strong>3：信号 “传丢” 或 “显示错误”</strong></p>
<p>显示器的硬件（比如液晶面板）有固定的 “响应速度”，比如扫一行像素需要的最小时间、回位需要的最小时间。如果主机发信号的 “像素时钟频率” 超过显示器的硬件极限（比如显示器只能扛 100MHz，主机发 150MHz），显示器就会 “跟不上”，导致部分像素信号传丢，画面出现花屏、闪烁。</p>
<h2 id="HPD中断流程"><a href="#HPD中断流程" class="headerlink" title="HPD中断流程"></a>HPD中断流程</h2><p>HPD（Hot Plug Detect）是DisplayPort&#x2F;HDMI等显示接口的一个物理信号&#x2F;引脚，用于检测显示器的插入和拔出。当显示器插入或拔出DP接口时，会产生电平变化，通过GPIO引脚可以检测到，从而产生中断。</p>
<ol>
<li><strong>驱动probe</strong>（初始化）<ul>
<li>申请资源（包括HPD GPIO、IRQ），注册中断，但<strong>不使能</strong>。</li>
</ul>
</li>
<li><strong>bind</strong><ul>
<li>资源ready，drm 桥&#x2F;encoder ready</li>
<li>使能主中断</li>
<li><strong>如果有HPD GPIO，调用<code>enable_irq(dp-&gt;hpd_irq);</code>，HPD中断生效</strong></li>
</ul>
</li>
<li><strong>后续HPD插拔事件发生</strong><ul>
<li>进入 <code>dw_dp_hpd_irq_handler</code></li>
<li>检查状态，调度<code>hpd_work</code>处理</li>
</ul>
</li>
</ol>
<p><strong>w_dp_probe</strong>的<strong>主要流程</strong>，每一步都做了哪些准备：</p>
<ol>
<li><strong>内存分配和结构体初始化</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = devm_kzalloc(dev, sizeof(*dp), GFP_KERNEL);</span><br></pre></td></tr></table></figure>

<ul>
<li>为整个DisplayPort驱动的数据结构分配内存。</li>
</ul>
<ol start="2">
<li><strong>获取设备ID</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = of_alias_get_id(dev-&gt;of_node, &quot;dp&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于区分多个DP端口。</li>
</ul>
<ol start="3">
<li><strong>从设备树读取硬件参数和配置</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = dw_dp_parse_dt(dp);</span><br></pre></td></tr></table></figure>

<ul>
<li>解析设备树，获得如“force-hpd”等属性，以及最大链路速率等硬件参数。</li>
</ul>
<ol start="4">
<li><strong>初始化锁、工作队列、完成量等内核同步机制</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;dp-&gt;irq_lock);</span><br><span class="line">INIT_WORK(&amp;dp-&gt;hpd_work, dw_dp_hpd_work);</span><br><span class="line">init_completion(&amp;dp-&gt;complete);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于保证多线程&#x2F;中断下数据安全与流程调度。</li>
</ul>
<ol start="5">
<li><strong>寄存器地址映射，初始化regmap</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base = devm_platform_ioremap_resource(pdev, 0);</span><br><span class="line">dp-&gt;regmap = devm_regmap_init_mmio(dev, base, &amp;dw_dp_regmap_config);</span><br></pre></td></tr></table></figure>

<ul>
<li>将物理寄存器地址映射到内核空间，方便后续读写。</li>
</ul>
<ol start="6">
<li><strong>获取PHY、时钟、复位等硬件资源</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;phy = devm_of_phy_get(dev, dev-&gt;of_node, NULL);</span><br><span class="line">dp-&gt;apb_clk = devm_clk_get(dev, &quot;apb&quot;);</span><br><span class="line">dp-&gt;aux_clk = devm_clk_get(dev, &quot;aux&quot;);</span><br><span class="line">dp-&gt;i2s_clk = devm_clk_get(dev, &quot;i2s&quot;);</span><br><span class="line">dp-&gt;spdif_clk = devm_clk_get(dev, &quot;spdif&quot;);</span><br><span class="line">dp-&gt;hclk = devm_clk_get_optional(dev, &quot;hclk&quot;);</span><br><span class="line">dp-&gt;hdcp_clk = devm_clk_get(dev, &quot;hdcp&quot;);</span><br><span class="line">dp-&gt;rstc = devm_reset_control_get(dev, NULL);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取各种物理层、总线、音视频等相关时钟、控制器。</li>
</ul>
<ol start="7">
<li><strong>申请HPD GPIO和中断资源</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;hpd_gpio = devm_gpiod_get_optional(dev, &quot;hpd&quot;, GPIOD_IN);</span><br><span class="line">if (dp-&gt;hpd_gpio) &#123;</span><br><span class="line">    dp-&gt;hpd_irq = gpiod_to_irq(dp-&gt;hpd_gpio);</span><br><span class="line">    irq_set_status_flags(dp-&gt;hpd_irq, IRQ_NOAUTOEN);</span><br><span class="line">    ret = devm_request_threaded_irq(dev, dp-&gt;hpd_irq, NULL,</span><br><span class="line">                    dw_dp_hpd_irq_handler,</span><br><span class="line">                    IRQF_TRIGGER_RISING |</span><br><span class="line">                    IRQF_TRIGGER_FALLING |</span><br><span class="line">                    IRQF_ONESHOT, &quot;dw-dp-hpd&quot;, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>申请HPD热插拔检测用的GPIO和中断，并注册中断处理函数（但不立即使能）。</li>
</ul>
<p><strong>常见的IRQ标志宏（内核通用）</strong></p>
<p>这些宏定义在 Linux 内核头文件 <code>&lt;linux/irq.h&gt;</code> 中，最常用的有：</p>
<ul>
<li><strong>IRQF_SHARED</strong><br>允许多个驱动共享同一个中断线。</li>
<li><strong>IRQF_TRIGGER_RISING</strong><br>上升沿触发</li>
<li><strong>IRQF_TRIGGER_FALLING</strong><br>下降沿触发</li>
<li><strong>IRQF_TRIGGER_HIGH</strong><br>高电平触发</li>
<li><strong>IRQF_TRIGGER_LOW</strong><br>低电平触发</li>
<li><strong>IRQF_ONESHOT</strong><br>用于线程化中断，禁止嵌套。</li>
<li><strong>IRQF_DISABLED</strong>（老版本）<br>触发时自动屏蔽本中断。</li>
</ul>
<p><strong>而<code>irq_set_status_flags</code>主要关注如下这些状态标志：</strong></p>
<ul>
<li><strong>IRQ_NOAUTOEN</strong><br>注册后不自动使能，需要手动<code>enable_irq()</code>。</li>
<li><strong>IRQ_NOREQUEST</strong><br>不允许通过<code>request_irq()</code>被申请。</li>
<li><strong>IRQ_NOPROBE</strong><br>不允许被探测（自动分配中断号时会跳过）。</li>
<li><strong>IRQ_NO_BALANCING</strong><br>禁止该中断在多核间迁移。</li>
<li><strong>IRQ_MOVE_PENDING</strong><br>标记该中断正在迁移。</li>
<li><strong>IRQ_DISABLE_UNLAZY</strong><br>禁止延迟disable。</li>
</ul>
<ol start="8">
<li><strong>申请主中断（IRQ）资源并注册中断处理函数</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;irq = platform_get_irq(pdev, 0);</span><br><span class="line">irq_set_status_flags(dp-&gt;irq, IRQ_NOAUTOEN);</span><br><span class="line">devm_request_threaded_irq(..., dw_dp_irq_handler, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li>负责AUX、HDCP等事件的中断处理。</li>
</ul>
<ol start="9">
<li><strong>分配和注册extcon（外部连接）设备</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;extcon = devm_extcon_dev_allocate(dev, dw_dp_cable);</span><br><span class="line">devm_extcon_dev_register(dev, dp-&gt;extcon);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于通知系统显示器连接状态。</li>
</ul>
<ol start="10">
<li><strong>注册音频驱动</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dw_dp_register_audio_driver(dp);</span><br><span class="line">devm_add_action_or_reset(dev, dw_dp_unregister_audio_driver, dp);</span><br></pre></td></tr></table></figure>

<ul>
<li>让DP支持音频输出。</li>
</ul>
<ol start="11">
<li><strong>注册AUX通道（DP的辅助通信通道）</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;aux.dev = dev;</span><br><span class="line">dp-&gt;aux.name = dev_name(dev);</span><br><span class="line">dp-&gt;aux.transfer = dw_dp_aux_transfer;</span><br><span class="line">drm_dp_aux_register(&amp;dp-&gt;aux);</span><br><span class="line">devm_add_action_or_reset(dev, dw_dp_aux_unregister, dp);</span><br></pre></td></tr></table></figure>

<ul>
<li>用于DP协议的辅助数据交换。</li>
</ul>
<ol start="12">
<li><strong>初始化DRM Bridge桥接结构体</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp-&gt;bridge.of_node = dev-&gt;of_node;</span><br><span class="line">dp-&gt;bridge.funcs = &amp;dw_dp_bridge_funcs;</span><br><span class="line">dp-&gt;bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_HPD;</span><br><span class="line">dp-&gt;bridge.type = DRM_MODE_CONNECTOR_DisplayPort;</span><br></pre></td></tr></table></figure>

<ul>
<li>为后续连接到DRM显示管理框架做准备。</li>
</ul>
<ol start="13">
<li><strong>设置split mode（双通道模式）相关参数</strong></li>
</ol>
<ul>
<li>如果设备树配置了split-mode，查找另一个DP端口并建立左右通道关联。</li>
</ul>
<ol start="14">
<li><strong>初始化HDCP加密流程相关结构体</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dw_dp_hdcp_init(dp);</span><br></pre></td></tr></table></figure>

<ul>
<li>为后续内容保护认证做准备。</li>
</ul>
<ol start="15">
<li><strong>注册component组件，等待系统调用bind继续初始化</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return component_add(dev, &amp;dw_dp_component_ops);</span><br></pre></td></tr></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">static int dw_dp_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">	struct device *dev = &amp;pdev-&gt;dev;</span><br><span class="line">	struct dw_dp *dp;</span><br><span class="line">	void __iomem *base;</span><br><span class="line">	int id, ret;</span><br><span class="line"></span><br><span class="line">	ret = dw_dp_parse_dt(dp);</span><br><span class="line">	if (ret)</span><br><span class="line">		return dev_err_probe(dev, ret, &quot;failed to parse DT\n&quot;);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;dp-&gt;irq_lock);</span><br><span class="line">	INIT_WORK(&amp;dp-&gt;hpd_work, dw_dp_hpd_work);</span><br><span class="line">	init_completion(&amp;dp-&gt;complete);</span><br><span class="line"></span><br><span class="line">	base = devm_platform_ioremap_resource(pdev, 0);</span><br><span class="line">	if (IS_ERR(base))</span><br><span class="line">		return PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	dp-&gt;regmap = devm_regmap_init_mmio(dev, base, &amp;dw_dp_regmap_config);</span><br><span class="line">	if (IS_ERR(dp-&gt;regmap))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;regmap),</span><br><span class="line">				     &quot;failed to create regmap\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;phy = devm_of_phy_get(dev, dev-&gt;of_node, NULL);</span><br><span class="line">	if (IS_ERR(dp-&gt;phy))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;phy),</span><br><span class="line">				     &quot;failed to get phy\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;apb_clk = devm_clk_get(dev, &quot;apb&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;apb_clk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;apb_clk),</span><br><span class="line">				     &quot;failed to get apb clock\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;aux_clk = devm_clk_get(dev, &quot;aux&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;aux_clk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;aux_clk),</span><br><span class="line">				     &quot;failed to get aux clock\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;i2s_clk = devm_clk_get(dev, &quot;i2s&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;i2s_clk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;i2s_clk),</span><br><span class="line">				     &quot;failed to get i2s clock\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;spdif_clk = devm_clk_get(dev, &quot;spdif&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;spdif_clk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;spdif_clk),</span><br><span class="line">				     &quot;failed to get spdif clock\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;hclk = devm_clk_get_optional(dev, &quot;hclk&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;hclk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;hclk),</span><br><span class="line">				     &quot;failed to get hclk\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;hdcp_clk = devm_clk_get(dev, &quot;hdcp&quot;);</span><br><span class="line">	if (IS_ERR(dp-&gt;hdcp_clk))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;hdcp_clk),</span><br><span class="line">				     &quot;failed to get hdcp clock\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;rstc = devm_reset_control_get(dev, NULL);</span><br><span class="line">	if (IS_ERR(dp-&gt;rstc))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;rstc),</span><br><span class="line">				     &quot;failed to get reset control\n&quot;);</span><br><span class="line"></span><br><span class="line">	dp-&gt;hpd_gpio = devm_gpiod_get_optional(dev, &quot;hpd&quot;, GPIOD_IN);</span><br><span class="line">	if (IS_ERR(dp-&gt;hpd_gpio))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;hpd_gpio),</span><br><span class="line">				     &quot;failed to get hpd GPIO\n&quot;);</span><br><span class="line">	if (dp-&gt;hpd_gpio) &#123;</span><br><span class="line">		dp-&gt;hpd_irq = gpiod_to_irq(dp-&gt;hpd_gpio);</span><br><span class="line">		if (dp-&gt;hpd_irq &lt; 0)</span><br><span class="line">			return dev_err_probe(dev, dp-&gt;hpd_irq,</span><br><span class="line">					     &quot;failed to get hpd irq\n&quot;);</span><br><span class="line"></span><br><span class="line">		irq_set_status_flags(dp-&gt;hpd_irq, IRQ_NOAUTOEN);</span><br><span class="line">		ret = devm_request_threaded_irq(dev, dp-&gt;hpd_irq, NULL,</span><br><span class="line">						dw_dp_hpd_irq_handler,</span><br><span class="line">						IRQF_TRIGGER_RISING |</span><br><span class="line">						IRQF_TRIGGER_FALLING |</span><br><span class="line">						IRQF_ONESHOT, &quot;dw-dp-hpd&quot;, dp);</span><br><span class="line">		if (ret) &#123;</span><br><span class="line">			dev_err(dev, &quot;failed to request HPD interrupt\n&quot;);</span><br><span class="line">			return ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp-&gt;irq = platform_get_irq(pdev, 0);</span><br><span class="line">	if (dp-&gt;irq &lt; 0)</span><br><span class="line">		return dp-&gt;irq;</span><br><span class="line"></span><br><span class="line">	irq_set_status_flags(dp-&gt;irq, IRQ_NOAUTOEN);</span><br><span class="line">	ret = devm_request_threaded_irq(dev, dp-&gt;irq, NULL, dw_dp_irq_handler,</span><br><span class="line">					IRQF_ONESHOT, dev_name(dev), dp);</span><br><span class="line">	if (ret) &#123;</span><br><span class="line">		dev_err(dev, &quot;failed to request irq: %d\n&quot;, ret);</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dp-&gt;extcon = devm_extcon_dev_allocate(dev, dw_dp_cable);</span><br><span class="line">	if (IS_ERR(dp-&gt;extcon))</span><br><span class="line">		return dev_err_probe(dev, PTR_ERR(dp-&gt;extcon),</span><br><span class="line">				     &quot;failed to allocate extcon device\n&quot;);</span><br><span class="line"></span><br><span class="line">	ret = devm_extcon_dev_register(dev, dp-&gt;extcon);</span><br><span class="line">	if (ret)</span><br><span class="line">		return dev_err_probe(dev, ret,</span><br><span class="line">				     &quot;failed to register extcon device\n&quot;);</span><br><span class="line"></span><br><span class="line">	ret = dw_dp_register_audio_driver(dp);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ret = devm_add_action_or_reset(dev, dw_dp_unregister_audio_driver, dp);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	dp-&gt;aux.dev = dev;</span><br><span class="line">	dp-&gt;aux.name = dev_name(dev);</span><br><span class="line">	dp-&gt;aux.transfer = dw_dp_aux_transfer;</span><br><span class="line">	ret = drm_dp_aux_register(&amp;dp-&gt;aux);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	ret = devm_add_action_or_reset(dev, dw_dp_aux_unregister, dp);</span><br><span class="line">	if (ret)</span><br><span class="line">		return ret;</span><br><span class="line"></span><br><span class="line">	dp-&gt;bridge.of_node = dev-&gt;of_node;</span><br><span class="line">	dp-&gt;bridge.funcs = &amp;dw_dp_bridge_funcs;</span><br><span class="line">	dp-&gt;bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID |</span><br><span class="line">			 DRM_BRIDGE_OP_HPD;</span><br><span class="line">	dp-&gt;bridge.type = DRM_MODE_CONNECTOR_DisplayPort;</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, dp);</span><br><span class="line"></span><br><span class="line">	if (device_property_read_bool(dev, &quot;split-mode&quot;)) &#123;</span><br><span class="line">		struct dw_dp *secondary = dw_dp_find_by_id(dev-&gt;driver, !dp-&gt;id);</span><br><span class="line"></span><br><span class="line">		if (!secondary)</span><br><span class="line">			return -EPROBE_DEFER;</span><br><span class="line"></span><br><span class="line">		dp-&gt;right = secondary;</span><br><span class="line">		dp-&gt;split_mode = true;</span><br><span class="line">		secondary-&gt;left = dp;</span><br><span class="line">		secondary-&gt;split_mode = true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dw_dp_hdcp_init(dp);</span><br><span class="line"></span><br><span class="line">	return component_add(dev, &amp;dw_dp_component_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="dp链路训练"><a href="#dp链路训练" class="headerlink" title="dp链路训练"></a>dp链路训练</h2><ul>
<li><strong>链路训练</strong>就是DisplayPort发送端（如主控芯片）和接收端（如显示器）商量好如何传输数据，让信号既稳定又高速。</li>
<li>包括“协商速率”、“设置通道”、“信号质量检测”、“自动降级”等步骤。</li>
</ul>
<p><strong>主要流程——dw_dp_link_train：</strong></p>
<ol>
<li><strong>能力检测——dw_dp_link_probe</strong><ul>
<li>发送端读取接收端（显示器）的能力，比如最大支持速率（bandwidth）、最大通道数（lanes）。</li>
<li>使用AUX通道读取DPCD寄存器（DisplayPort Configuration Data）。</li>
<li>读取sink_count（接收端数量），确保显示器已连接。</li>
<li>判断支持哪些训练模式（如TPS3&#x2F;TPS4）。</li>
</ul>
</li>
<li><strong>配置参数——dw_dp_link_configure</strong><ul>
<li>根据双方能力，设置合适的速率和通道数，配置本地PHY和寄存器。</li>
</ul>
</li>
<li><strong>时钟恢复（Clock Recovery）——dw_dp_link_clock_recovery</strong><ul>
<li>发送端发出特殊的训练信号（Pattern 1），显示器检测信号是否稳定。</li>
<li>发送端和接收端通过AUX通道不断调整电气参数（如电压摆幅、预加重），直到时钟信号稳定。</li>
<li>检查时钟恢复是否成功（<code>drm_dp_clock_recovery_ok</code>）。</li>
<li>如果失败，驱动会自动降低速率或减少通道数，然后重试。</li>
</ul>
</li>
<li><strong>信道均衡（Channel Equalization）——dw_dp_link_channel_equalization</strong><ul>
<li>时钟恢复成功后，进入信道均衡阶段，发出Pattern 2&#x2F;3&#x2F;4等训练信号，检测信号完整性和误码率。</li>
<li>同样通过AUX通道反馈参数，不断调整，直到信号质量达标。</li>
<li>检查均衡是否成功（<code>drm_dp_channel_eq_ok</code>）。</li>
<li>如果失败，同样降级参数重试。</li>
</ul>
</li>
<li><strong>训练成功，关闭训练信号，进入正式数据传输模式。</strong><ul>
<li><code>dw_dp_link_train_full</code>（全流程复合训练）</li>
<li><code>dw_dp_link_train_fast</code>（如果显示器支持快速训练）</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dw_dp_link_train (主流程入口)</span><br><span class="line">│</span><br><span class="line">├── dw_dp_link_probe (能力检测)</span><br><span class="line">│</span><br><span class="line">├── dw_dp_link_configure (参数配置)</span><br><span class="line">│</span><br><span class="line">├── dw_dp_link_clock_recovery (时钟恢复)</span><br><span class="line">│   ├── dw_dp_link_train_set_pattern (设置训练信号)</span><br><span class="line">│   ├── dw_dp_link_train_update_vs_emph (调整电气参数)</span><br><span class="line">│   └── drm_dp_dpcd_read_link_status (读取显示器反馈)</span><br><span class="line">│</span><br><span class="line">├── dw_dp_link_channel_equalization (信道均衡)</span><br><span class="line">│   ├── dw_dp_link_train_set_pattern (设置训练信号)</span><br><span class="line">│   ├── dw_dp_link_train_update_vs_emph (调整电气参数)</span><br><span class="line">│   └── drm_dp_dpcd_read_link_status (读取显示器反馈)</span><br><span class="line">│</span><br><span class="line">└── dw_dp_link_train_set_pattern(DP_TRAINING_PATTERN_DISABLE) (关闭训练信号)</span><br></pre></td></tr></table></figure>





<h2 id="内核同步机制"><a href="#内核同步机制" class="headerlink" title="内核同步机制"></a>内核同步机制</h2><h3 id="一、工作队列（Workqueue）"><a href="#一、工作队列（Workqueue）" class="headerlink" title="一、工作队列（Workqueue）"></a>一、工作队列（Workqueue）</h3><ol>
<li><strong>基本概念</strong></li>
</ol>
<ul>
<li><strong>工作队列（workqueue）</strong>是Linux内核提供的一种异步任务机制。</li>
<li>用于将某些需要“慢慢做”的工作（比如耗时操作、不能在中断上下文里做的事）从中断或其他上下文“切换”到内核线程环境下执行。</li>
<li>本质上就是：<strong>把活扔到后台，让内核帮你排队慢慢做，不阻塞当前流程</strong>。</li>
</ul>
<ol start="2">
<li>为什么需要工作队列？</li>
</ol>
<ul>
<li>有些操作不能在中断环境做（比如睡眠、访问用户空间、分配大块内存）。</li>
<li>如果直接在中断里做这些事，会导致系统卡死或异常。</li>
<li>工作队列让你只负责“标记”要做什么，剩下的交给内核安排。</li>
</ul>
<ol start="3">
<li><strong>使用流程（结合你的代码）</strong></li>
</ol>
<p><strong>定义：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct work_struct hpd_work;</span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;dp-&gt;hpd_work, dw_dp_hpd_work);</span><br></pre></td></tr></table></figure>

<ul>
<li>这表示：定义一个叫<code>hpd_work</code>的工作，并指定它的回调函数是<code>dw_dp_hpd_work</code>。</li>
</ul>
<p><strong>调度执行（通常在中断处理函数里）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_work(&amp;dp-&gt;hpd_work);</span><br></pre></td></tr></table></figure>

<ul>
<li>这表示：把<code>hpd_work</code>这个工作放到系统的工作队列里，稍后由内核线程执行<code>dw_dp_hpd_work</code>函数。</li>
</ul>
<p><strong>回调函数内容（可以做比较复杂&#x2F;耗时的操作）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void dw_dp_hpd_work(struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    // 检查HPD状态、重训练链路、重新配置视频流等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-工作队列的特点"><a href="#4-工作队列的特点" class="headerlink" title="4. 工作队列的特点"></a>4. 工作队列的特点</h3><ul>
<li>是异步的，非阻塞的</li>
<li>可以安全地做睡眠、耗时、复杂操作</li>
<li>适合从中断、定时器等不能阻塞的上下文切换到内核线程环境</li>
</ul>
<hr>
<h3 id="二、完成量（Completion）"><a href="#二、完成量（Completion）" class="headerlink" title="二、完成量（Completion）"></a>二、完成量（Completion）</h3><p><strong>1. 基本概念</strong></p>
<ul>
<li><strong>完成量（completion）</strong>是Linux内核提供的一种同步机制，用于“等待某个事件完成”。</li>
<li>适合场景：一个线程需要等另一个地方的任务完成（比如等硬件中断、DMA传输、AUX通道返回结果等）。</li>
</ul>
<p><strong>2. 使用流程（结合你的代码）</strong></p>
<p><strong>定义：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct completion complete;</span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_completion(&amp;dp-&gt;complete);</span><br></pre></td></tr></table></figure>

<p><strong>等待完成：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_for_completion_timeout(&amp;dp-&gt;complete, timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用这个函数的地方会阻塞，直到完成量被“唤醒”或者超时。</li>
</ul>
<p><strong>唤醒完成（通常在中断处理函数里）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complete(&amp;dp-&gt;complete);</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>complete()</code>后，所有等待这个完成量的线程都会被唤醒，继续执行。</li>
</ul>
<p><strong>3. 应用场景</strong></p>
<ul>
<li>例如发送AUX命令后，等待硬件中断返回结果（如你的<code>dw_dp_aux_transfer</code>函数）。</li>
<li>线程A发起请求并<code>wait_for_completion</code>，线程B（比如中断上下文）在任务完成后<code>complete()</code>它。</li>
</ul>
<hr>
<h3 id="三、其它常见同步机制（简单了解）"><a href="#三、其它常见同步机制（简单了解）" class="headerlink" title="三、其它常见同步机制（简单了解）"></a>三、其它常见同步机制（简单了解）</h3><ul>
<li><strong>信号量（semaphore）</strong>：用于控制访问共享资源，允许多个线程访问，但有最大数量限制。</li>
<li><strong>互斥锁（mutex）</strong>：只允许一个线程访问临界区，防止数据竞争。</li>
<li><strong>自旋锁（spinlock）</strong>：适合在不能睡眠的环境下（如中断），很快执行加锁&#x2F;解锁操作。</li>
<li><strong>原子变量（atomic_t）</strong>：用于简单的计数、状态标记等，保证操作原子性。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">完成量（completion）</th>
<th align="left">信号量（semaphore）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主要用途</td>
<td align="left">等待事件完成，点对点同步</td>
<td align="left">控制资源并发访问，资源池</td>
</tr>
<tr>
<td align="left">支持计数</td>
<td align="left">不支持（只用于事件的“完成”信号）</td>
<td align="left">支持（可设置并发数量）</td>
</tr>
<tr>
<td align="left">典型场景</td>
<td align="left">等某个硬件事件&#x2F;任务完成</td>
<td align="left">限制并发访问、资源管理</td>
</tr>
<tr>
<td align="left">多线程支持</td>
<td align="left">通常一个等待者，一个唤醒者</td>
<td align="left">多个等待者、多个持有者</td>
</tr>
<tr>
<td align="left">API差异</td>
<td align="left"><code>init_completion</code>, <code>wait_for_completion</code>, <code>complete</code></td>
<td align="left"><code>sema_init</code>, <code>down</code>, <code>up</code></td>
</tr>
<tr>
<td align="left">内核使用频率</td>
<td align="left">用于等待异步事件（如AUX、DMA完成）</td>
<td align="left">用于限制设备并发访问（较早期常用）</td>
</tr>
</tbody></table>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/covers/11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/linux_driver/work_queue/" title="工作队列"><img class="cover" src="/img/covers/10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">工作队列</div></div><div class="info-2"><div class="info-item-1">工作队列的介绍和使用：https://blog.csdn.net/xiaoheshang_123/article/details/147374327 详解：https://devpress.csdn.net/linux/66d02dcbc618435984a3a31b.html </div></div></div></a><a class="pagination-related" href="/hot100/" title="hot100"><img class="cover" src="/img/covers/17.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">hot100</div></div><div class="info-2"><div class="info-item-1">  力扣热题100题型类别心得： 1、哈希表：哈希表的使用是为了O(1)获取已经遍历过的信息 如两数之和&#x3D;target，暴力直接两个for循环去找到两个和为目标值的数，也就是遍历数组，拿当前数又去遍历一遍后面的数，实际上这些数的信息在第一次遍历时就已经得到了，暴力解法没有保留这些信息以至于每次都要重新获取；哈希表让机器有了信息记忆。我们得出减少一层循环，优化时间复杂度的一个办法就是记忆已经遍历过的信息 再比如要求最长连续序列，就要从最小值开始数最长的连续序列，而这恰好是数组排序O(n^2)，获取连续序列也就是要知道这个数的上一个和下一个，而通过两个哈希表就可以记录这段连续序列的左边界和右边界，同时更新左右边界 2、双指针 双指针有几种常见的题型，同向双指针，相向双指针，滑动窗口~ 相向双指针常见于求取一段范围中的值。例如盛水容器和接雨水，就是木桶问题，盛水的多少决定于最短木板，不断更新最短的木板即可 同双双指针常见快慢指针，追及问题等 滑动窗口一般分为定长和不定长，一般我都用不定长的方式来写，然后加上当r-l等于值时就取值 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">驱动入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%EF%BC%9Ahelloworld"><span class="toc-number">1.1.</span> <span class="toc-text">第一个驱动：helloworld</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E5%B0%86%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.</span> <span class="toc-text">第一种方法：将驱动编译内核模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">模块加载命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Emenuconfig%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">与menuconfig相关的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kconfig%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">Kconfig语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A%E5%B0%86%E9%A9%B1%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%9B%E5%86%85%E6%A0%B8"><span class="toc-number">1.6.</span> <span class="toc-text">第二种方法：将驱动编译进内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82"><span class="toc-number">1.7.</span> <span class="toc-text">驱动模块传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">1.8.</span> <span class="toc-text">符号表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.9.</span> <span class="toc-text">系统如何运行驱动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">字符设备基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">2.1.</span> <span class="toc-text">设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">2.2.</span> <span class="toc-text">字符设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-operations"><span class="toc-number">2.3.</span> <span class="toc-text">file_operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-number">2.4.</span> <span class="toc-text">设备节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">用户空间和内核空间的数据交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.6.</span> <span class="toc-text">设备结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">设备管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#USB"><span class="toc-number">4.1.</span> <span class="toc-text">USB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-number">4.2.</span> <span class="toc-text">SPI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IIC"><span class="toc-number">4.3.</span> <span class="toc-text">IIC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAN%E2%80%94%E2%80%94ctl-area-net"><span class="toc-number">4.4.</span> <span class="toc-text">CAN——ctl area net</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ioctl%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">ioctl接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pinctrl%E5%92%8CGPIO%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.</span> <span class="toc-text">pinctrl和GPIO子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl"><span class="toc-number">6.1.</span> <span class="toc-text">pinctrl</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">6.1.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">6.1.2.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.1.3.</span> <span class="toc-text">复用模式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">6.1.4.</span> <span class="toc-text">如何配置引脚复用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO"><span class="toc-number">6.2.</span> <span class="toc-text">GPIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EDID"><span class="toc-number">7.</span> <span class="toc-text">EDID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HPD%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">HPD中断流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dp%E9%93%BE%E8%B7%AF%E8%AE%AD%E7%BB%83"><span class="toc-number">9.</span> <span class="toc-text">dp链路训练</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">10.</span> <span class="toc-text">内核同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%88Workqueue%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">一、工作队列（Workqueue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">10.2.</span> <span class="toc-text">4. 工作队列的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%8C%E6%88%90%E9%87%8F%EF%BC%88Completion%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">二、完成量（Completion）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E5%AE%83%E5%B8%B8%E8%A7%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%88%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">10.4.</span> <span class="toc-text">三、其它常见同步机制（简单了解）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Jerold</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>