<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>显示系统 | Jerold‘s PNote</title><meta name="author" content="Jerold"><meta name="copyright" content="Jerold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="1 https:&#x2F;&#x2F;doc.embedfire.com&#x2F;linux&#x2F;rk356x&#x2F;linux_base&#x2F;zh&#x2F;latest&#x2F;linux_app&#x2F;drm&#x2F;drm.html 介绍DRM的图像系统可以分为两部分  应用层– libdrm 内核驱动层— GEM, KMS  libdrm: 对底层接口进行封装，向上层提供通用的API接口，主要是对各种IOCTL接口进行封装。 KMS(Kernel Mode">
<meta property="og:type" content="article">
<meta property="og:title" content="显示系统">
<meta property="og:url" content="http://example.com/linux_driver/drm/index.html">
<meta property="og:site_name" content="Jerold‘s PNote">
<meta property="og:description" content="1 https:&#x2F;&#x2F;doc.embedfire.com&#x2F;linux&#x2F;rk356x&#x2F;linux_base&#x2F;zh&#x2F;latest&#x2F;linux_app&#x2F;drm&#x2F;drm.html 介绍DRM的图像系统可以分为两部分  应用层– libdrm 内核驱动层— GEM, KMS  libdrm: 对底层接口进行封装，向上层提供通用的API接口，主要是对各种IOCTL接口进行封装。 KMS(Kernel Mode">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/14.jpg">
<meta property="article:published_time" content="2025-10-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-10-24T16:00:00.000Z">
<meta property="article:author" content="Jerold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/14.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/linux_driver/drm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '显示系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jerold‘s PNote</span></a><a class="nav-page-title" href="/"><span class="site-name">显示系统</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">显示系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-24T16:00:00.000Z" title="发表于 2025-10-25 2025-10-25T00:00:00+08:00">2025-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-24T16:00:00.000Z" title="更新于 2025-10-25 2025-10-25T00:00:00+08:00">2025-10-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>1</p>
<p><a target="_blank" rel="noopener" href="https://doc.embedfire.com/linux/rk356x/linux_base/zh/latest/linux_app/drm/drm.html">https://doc.embedfire.com/linux/rk356x/linux_base/zh/latest/linux_app/drm/drm.html</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>DRM的图像系统可以分为两部分</p>
<ul>
<li>应用层– <strong>libdrm</strong></li>
<li>内核驱动层— <strong>GEM</strong>, <strong>KMS</strong></li>
</ul>
<p>libdrm: 对底层接口进行封装，向上层提供通用的API接口，主要是对各种IOCTL接口进行封装。</p>
<p>KMS(Kernel Mode Setting): 即Mode setting：更新画面和设置显示参数。</p>
<ol>
<li>更新画面：显示buffer的切换，多图层的合成方式，以及每个图层的显示位置。</li>
<li>设置显示参数：包括分辨率、刷新率、电源状态（休眠唤醒）等。</li>
</ol>
<p>GEM(Graphic Execution Manager): 主要负责显示buffer的分配和释放，内存管理与同步。</p>
<h2 id="与fb区别"><a href="#与fb区别" class="headerlink" title="与fb区别"></a>与fb区别</h2><p><img src="/./../../pic/linux_driver/image-20251025012215595-1761588854123-1.png" alt="image-20251025012215595"></p>
<h4 id="DRM-Framebuffer"><a href="#DRM-Framebuffer" class="headerlink" title="DRM Framebuffer"></a>DRM Framebuffer</h4><p>一片存放图像的内存区域， 且需要设置图像的格式(RGB888,YUV,C8等)以及画布的大小</p>
<h4 id="CRTC"><a href="#CRTC" class="headerlink" title="CRTC"></a>CRTC</h4><p>阴极射线显像管控制器—— 电子枪打出的电子撞击到屏幕上的荧光物质使其发光，</p>
<p>在DRM显示系统中CRTC会配置display timings和显示分辨率(Planes提供)来扫描framebuffer上的内容，传给Encoder。</p>
<p>LCD屏需要一定的时序（display timings）才能正确显示东西， 因此，CRTC在这里就有着很重要的作用，生成视频模式定时信号,输出内容到Encoder中，Encoder和Connector则只作为数据的转换和传输</p>
<blockquote>
<p>lcd时序详解以及如何适配dts中timing：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1326393">https://developer.aliyun.com/article/1326393</a></p>
</blockquote>
<h2 id="显示接口"><a href="#显示接口" class="headerlink" title="显示接口"></a>显示接口</h2><p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_76151015/article/details/149425565">https://blog.csdn.net/2301_76151015/article/details/149425565</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_76151015/article/details/149424974?spm=1001.2101.3001.10752">https://blog.csdn.net/2301_76151015/article/details/149424974?spm=1001.2101.3001.10752</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46768828/article/details/113852598">https://blog.csdn.net/weixin_46768828/article/details/113852598</a></p>
<p>MIPI是一系列显示接口协议，包含液晶、摄像头等；液晶所使用的的MIPI接口是dsi</p>
<p><strong>DSI协议层</strong></p>
<p><img src="/./../../pic/linux_driver/image-20251027021422892-1761588854124-2.png" alt="image-20251027021422892"></p>
<p>物理层：硬件电路控制，将所有的数据转换为电平信号，以输出或者输入。这一层之间的连接就是DSI的接口连接了</p>
<p>通道管理层：对数据进行管理，将数据分给给Data通道或者从Data通道接收到后进行重组，以便交给下一层</p>
<p>协议层：对数据进行封包、检验等</p>
<p>应用层：初始化参数或者图像数据就在这一层发送或者接收。</p>
<blockquote>
<p><strong>Panel Driver IC</strong> ：<strong>显示面板驱动芯片</strong>。</p>
<p>电脑的CPU（显卡）输出的是数字信号，但这个信号无法直接让液晶分子转动或让OLED像素点发光。Panel Driver IC 就扮演了一个“翻译官”和“指挥官”的角色，它的主要工作包括：</p>
<ol>
<li><strong>接收信号：</strong> 从设备的主板或显卡接收图像数据信号（数字信号）。</li>
<li><strong>处理和翻译：</strong> 将接收到的数字信号进行处理和转换，变成面板能够理解的特定格式的指令。</li>
<li><strong>精确控制：</strong><ul>
<li><strong>对于LCD屏幕：</strong> 它需要产生精确的电压，来控制每个<strong>子像素</strong>（红、绿、蓝）的液晶分子的偏转角度，从而控制背光透过的多少，形成不同的灰阶和颜色。它通常分为两个部分：<ul>
<li><strong>Source Driver（源极驱动芯片）：</strong> 控制每一列像素的电压。</li>
<li><strong>Gate Driver（栅极驱动芯片）：</strong> 控制每一行像素的开关。</li>
</ul>
</li>
<li><strong>对于OLED屏幕：</strong> 它需要精确控制流向每个像素点的电流大小，因为电流直接决定了OLED材料的发光亮度。这需要更精密的控制，所以技术也更复杂。</li>
</ul>
</li>
<li><strong>时序控制：</strong> 确保每一行、每一列的像素都在正确的时刻被激活，以形成一幅完整、稳定的画面，避免出现拖影、闪烁等问题。</li>
</ol>
</blockquote>
<p>其中短数据包主要用于传输命令、读写寄存器。短数据包长度为4byte，只有数据包头。</p>
<p>长数据包主要用用于传输大量图象数据或部分控制命令。长数据包长度为6 ~ 65541字节，包括4byte数据包头、0~65535byte有效数据、2byte数据包尾。</p>
<p><strong>DSI支持的液晶类型</strong></p>
<ul>
<li>video mode：host端一直发数据送显</li>
<li>command mode：当画面变化时，host才发数据送显</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Video Mode（视频模式）</th>
<th align="left">Command Mode（命令模式）</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心工作原理</strong></td>
<td align="left">显示控制器<strong>持续不断地</strong>将帧缓冲区的<strong>像素数据</strong>以固定频率“推送”到显示面板。</td>
<td align="left">主机处理器<strong>通过命令</strong>来“指挥”显示驱动器，只有<strong>图像变化的部分</strong>才需要更新。</td>
</tr>
<tr>
<td align="left"><strong>数据流</strong></td>
<td align="left">高速、连续、单向的数据流，像视频流。</td>
<td align="left">低速、间歇、双向（可能）的数据流，像指令通信。<strong>发送数据以及读取状态信息</strong></td>
</tr>
<tr>
<td align="left"><strong>类比</strong></td>
<td align="left"><strong>电视&#x2F;显示器</strong>：持续接收视频信号，不管画面是否变化。</td>
<td align="left"><strong>智能手机&#x2F;智能手表屏幕</strong>：大部分时间静态显示，只有你操作时局部刷新。</td>
</tr>
<tr>
<td align="left"><strong>总线负载</strong></td>
<td align="left"><strong>高</strong>。即使显示静态图片，总线也在满负荷传输数据。</td>
<td align="left"><strong>低</strong>。只在初始化或更新画面时传输命令和少量数据。</td>
</tr>
<tr>
<td align="left"><strong>功耗</strong></td>
<td align="left"><strong>高</strong>。因为接口电路和总线持续工作。</td>
<td align="left"><strong>低</strong>。在显示静态画面时，大部分电路可以进入低功耗状态。</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">大屏幕显示器、电视、VR头盔等需要持续高速刷新的场景。</td>
<td align="left">智能手机、智能手表、物联网设备等对功耗极其敏感的设备。</td>
</tr>
<tr>
<td align="left">显示同步刷新机制</td>
<td align="left">通过将v-sync及h-sync信号包含在数据包里发送给panel来做同步</td>
<td align="left">通过TE pin来同步</td>
</tr>
</tbody></table>
<blockquote>
<p>RGB不同的是RGB专门有v-sync以及h-sync 管脚来同步</p>
</blockquote>
<p><img src="/./../../pic/linux_driver/image-20251027025141033-1761588854124-3.png" alt="image-20251027025141033"></p>
<p><strong>mipi屏的三种传输模式：</strong></p>
<p><strong>Burst mode:</strong> 	HSS——》HBP——》HACTIVE——》BLLP——》HFP</p>
<p>在 Burst 模式下，<strong>每一帧视频数据被紧凑地打包成多个长包（Long Packet）</strong>，并且在一个短时间段内以 <strong>HS 模式</strong>连续发送到显示器。</p>
<p>特点：</p>
<ul>
<li>没有显示同步（如 VSYNC、HSYNC）显式脉冲；</li>
<li>所有数据必须在一个刷新周期内发送完；</li>
<li>控制端必须掌握严格的帧率和定时；</li>
<li><strong>接收端必须有自带时序控制器（TCON）</strong>，才能正确解码图像；</li>
<li>显示屏不依赖 DSI 传输的同步信号，而是依靠自身内部定时。</li>
</ul>
<p><img src="/./../../pic/linux_driver/image-20251027025214422-1761588854124-4.png" alt="image-20251027025214422"></p>
<p><strong>协议核心机制</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38131812/article/details/122394519">https://blog.csdn.net/qq_38131812/article/details/122394519</a></p>
<p>切换机制：</p>
<ul>
<li><p>初始为 LP 模式（空闲）</p>
</li>
<li><p>向 DSI 控制器写入寄存器，触发切换到 HS 模式</p>
</li>
<li><p>PHY 层发出 LP11 → LP01 → LP00 → HS entry</p>
</li>
<li><p>连续发送图像数据</p>
</li>
<li><p>传输完成后，HS stop + LP00 → LP11</p>
</li>
</ul>
<p>Packet 传输（DCS&#x2F;DSI 协议）</p>
<ul>
<li><p>使用 Data Type &#x3D; 0x3E（RGB888 长包）</p>
</li>
<li><p>Long Packet 格式：</p>
</li>
</ul>
<p><strong>DSI时钟</strong></p>
<p>Clock+ Clock-的连接线，就是DSI的时钟信号线了。主从设备依靠这组时钟线上传输的时钟信号来指挥数据的传输和解析（LP模式下不需要这组时钟，因为在LP模式下的数据传输依靠的是Data0+ Data0-的异或来作为时钟的）。</p>
<p><img src="/./../../pic/linux_driver/image-20251028013856802.png" alt="image-20251028013856802"></p>
<p>由于图像传输有一些时序要求，方便数据的同步等，所以每一行都会用一些无用（非图像数据）的像素（pixel）传输。</p>
<p>如RGB888格式图像代表一个像素点用24bit表示</p>
<ul>
<li><p>实际双边沿采样，一个时钟可以穿两个bit的数据</p>
</li>
<li><p>展锐：Bitclk &#x3D; Total pixel x 位深 x 1.2 &#x2F; lane number （包含包头包尾协议数据）；</p>
<p>RK平台通常是在理论计算出后直接加上100Mhz</p>
<p>高通在burst mode时，压缩图像，留出时间来传输协议数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Total pixel = H-total x V-total x fps（一般是60）</span><br><span class="line">Bitclk= Total pixel  x  位深/lane number</span><br><span class="line">pclk(Dsi pixel clock) = (Byteclk * lane number)/bpp(byte) = Total pixel </span><br></pre></td></tr></table></figure>



<p><strong>DSI模式</strong></p>
<p>CLOCK有三个模式：</p>
<ul>
<li><p>低功耗模式LPM （Low Power Mode）</p>
</li>
<li><p>超低功耗模式ULPM(Ultra Low Power Mode)</p>
</li>
<li><p>高速时钟模式HSCM(High Speed Clock Mode)</p>
</li>
</ul>
<p>DATA有三个模式：</p>
<ul>
<li><p>Escape Mode,</p>
</li>
<li><p>High-Speed Data Transmission,</p>
</li>
<li><p>Bus Turnaround Request</p>
</li>
</ul>
<p><img src="/./../../pic/linux_driver/image-20251028014719668.png" alt="image-20251028014719668"></p>
<h2 id="D-phy"><a href="#D-phy" class="headerlink" title="D-phy"></a>D-phy</h2><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2093324">https://cloud.tencent.com/developer/article/2093324</a></p>
</article><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/covers/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/linux_driver/serdes/" title="serdes"><img class="cover" src="/img/covers/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">serdes</div></div><div class="info-2"><div class="info-item-1">1 介绍加串器解串器是一种主流的时分多路复用点对点(P2P)的串行通信技术  通过将时间划分为多个时间片（时隙），每个时间片由不同信号轮流占用  将发送端多路低速并行信号转换为高速串行信号，经过光缆或铜线等媒体在接收端变为低速并行信号 大大减少两端排线数量，减少所需的传输信道和器件引脚数目，提升信号的传输速度，从而大大降低通信成本。 背景： a)、时钟到达两个芯片的传播延时不相等(clock skew) b)、并行数据各个bit的传播延时不相等(data skew) c)、时钟的传播延时和数据的传播延时不一致(skew between data and clock) </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8Efb%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">与fb区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DRM-Framebuffer"><span class="toc-number">2.0.1.</span> <span class="toc-text">DRM Framebuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CRTC"><span class="toc-number">2.0.2.</span> <span class="toc-text">CRTC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">显示接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D-phy"><span class="toc-number">4.</span> <span class="toc-text">D-phy</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Jerold</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>