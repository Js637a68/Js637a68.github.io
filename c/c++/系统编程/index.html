<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>linux编程基础 | Jerold‘s PNote</title><meta name="author" content="Jerold"><meta name="copyright" content="Jerold"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="linux常见目录： &#x2F;bin: &#x2F;usr&#x2F;bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 &#x2F;boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：&#x2F;boot&#x2F;vmlinuz，系统引导管理器：&#x2F;boot&#x2F;grub。 &#x2F;dev：存放linux系统下的设备文件，">
<meta property="og:type" content="article">
<meta property="og:title" content="linux编程基础">
<meta property="og:url" content="http://example.com/c/c++/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Jerold‘s PNote">
<meta property="og:description" content="linux常见目录： &#x2F;bin: &#x2F;usr&#x2F;bin: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。 &#x2F;boot：放置linux系统启动时用到的一些文件，如Linux的内核文件：&#x2F;boot&#x2F;vmlinuz，系统引导管理器：&#x2F;boot&#x2F;grub。 &#x2F;dev：存放linux系统下的设备文件，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/covers/6.jpg">
<meta property="article:published_time" content="2024-05-22T08:32:45.000Z">
<meta property="article:modified_time" content="2024-05-22T08:32:45.000Z">
<meta property="article:author" content="Jerold">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/covers/6.jpg"><link rel="shortcut icon" href="/img/logo.jpg"><link rel="canonical" href="http://example.com/c/c++/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux编程基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/bg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/covers/6.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jerold‘s PNote</span></a><a class="nav-page-title" href="/"><span class="site-name">linux编程基础</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">linux编程基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-22T08:32:45.000Z" title="发表于 2024-05-22 2024-05-22T16:32:45+08:00">2024-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-22T08:32:45.000Z" title="更新于 2024-05-22 2024-05-22T16:32:45+08:00">2024-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<h3 id="linux常见目录："><a href="#linux常见目录：" class="headerlink" title="linux常见目录："></a>linux常见目录：</h3><ul>
<li><strong>&#x2F;bin:</strong> <strong>&#x2F;usr&#x2F;bin:</strong> 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</li>
<li><strong>&#x2F;boot：</strong>放置linux系统启动时用到的一些文件，如Linux的内核文件：&#x2F;boot&#x2F;vmlinuz，系统引导管理器：&#x2F;boot&#x2F;grub。</li>
<li><strong>&#x2F;dev：</strong>存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount &#x2F;dev&#x2F;cdrom &#x2F;mnt。</li>
<li><strong>&#x2F;etc</strong>：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 &#x2F;etc&#x2F;inittab、&#x2F;etc&#x2F;fstab、&#x2F;etc&#x2F;init.d、&#x2F;etc&#x2F;X11、&#x2F;etc&#x2F;sysconfig、&#x2F;etc&#x2F;xinetd.d。</li>
<li><strong>&#x2F;home：</strong>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，<del>表示当前用户的家目录，</del>edu 表示用户 edu 的家目录。</li>
<li><strong>&#x2F;lib: &#x2F;usr&#x2F;lib: &#x2F;usr&#x2F;local&#x2F;lib</strong>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。</li>
<li><strong>&#x2F;lost+fount：</strong>系统异常产生错误时，会将一些遗失的片段放置于此目录下。</li>
<li><strong>&#x2F;mnt:&#x2F;media：</strong>光盘默认挂载点，通常光盘挂载于 &#x2F;mnt&#x2F;cdrom 下，也不一定，可以选择任意位置进行挂载。</li>
<li><strong>&#x2F;opt：</strong>给主机额外安装软件所摆放的目录。</li>
<li><strong>&#x2F;proc</strong>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 &#x2F;proc&#x2F;cpuinfo、&#x2F;proc&#x2F;interrupts、&#x2F;proc&#x2F;dma、&#x2F;proc&#x2F;ioports、&#x2F;proc&#x2F;net&#x2F;* 等。</li>
<li><strong>&#x2F;root：</strong>系统管理员root的家目录。</li>
<li><strong>&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;sbin：</strong>放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 &#x2F;bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。</li>
<li>**&#x2F;tmp**<strong>：</strong>一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。</li>
<li><strong>&#x2F;srv：</strong>服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 &#x2F;srv&#x2F;www 内。</li>
<li><strong>&#x2F;usr</strong>：应用程序存放目录，&#x2F;usr&#x2F;bin 存放应用程序，&#x2F;usr&#x2F;share 存放共享数据，&#x2F;usr&#x2F;lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。&#x2F;usr&#x2F;local: 存放软件升级包。&#x2F;usr&#x2F;share&#x2F;doc: 系统说明文件存放目录。&#x2F;usr&#x2F;share&#x2F;man: 程序说明文件存放目录。</li>
<li><strong>&#x2F;var：</strong>放置系统执行过程中经常变化的文件，如随时更改的日志文件 &#x2F;var&#x2F;log，&#x2F;var&#x2F;log&#x2F;message：所有的登录文件存放目录，&#x2F;var&#x2F;spool&#x2F;mail：邮件存放的目录，&#x2F;var&#x2F;run:程序或服务启动后，其PID存放在该目录下。</li>
</ul>
<h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p>移到头部尾部：ctrl + a&#x2F;e</p>
<p>删除前后字符或所有字符：ctrl + h&#x2F;d ，ctrl + u&#x2F;k</p>
<p>窗口&#x2F;标签：ctrl+shit+ N&#x2F;Q  T&#x2F;W</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p><strong>man</strong> <strong>中各个</strong> <strong>section</strong> <strong>意义如下：</strong></p>
<blockquote>
<p>deng@itcast:~$ man man</p>
</blockquote>
<p>1)．Standard commands（标准命令）</p>
<p>2)．System calls（系统调用，如open,write）</p>
<p>3)．Library functions（库函数，如printf,fopen）</p>
<p>4)．Special devices（设备文件的说明，&#x2F;dev下各种设备）</p>
<p>5)．File formats（文件格式，如passwd）</p>
<p>6)．Games and toys（游戏和娱乐）</p>
<p>7)．Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量）</p>
<p>8)．Administrative Commands（管理员命令，如ifconfig）</p>
<p>通常，Unix&#x2F;Linux系统中常用的文件类型有7种：普通文件、目录文件、设备文件、管道文件、链接文件和套接字。</p>
<p>命令：</p>
<p>du：查看指定目录或文件</p>
<p>df：查看文件系统占用</p>
<p>find：-name&#x2F;-size&#x2F;-type</p>
<p>grep：-r搜索目录， -v求反</p>
<p>tar、gzip，unzip</p>
<p>chmod u&#x2F;g&#x2F;o + +&#x2F;-&#x2F;&#x3D;</p>
<p>chown</p>
<p>chgrp</p>
<p>ln：-s—》readlink</p>
<h3 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h3><table>
<thead>
<tr>
<th align="left"><strong>选项</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">-o file</td>
<td align="left">指定生成的输出文件名为file</td>
</tr>
<tr>
<td align="left">-E</td>
<td align="left">只进行预处理</td>
</tr>
<tr>
<td align="left">-S(大写)</td>
<td align="left">只进行预处理和编译</td>
</tr>
<tr>
<td align="left">-c(小写)</td>
<td align="left">只进行预处理、编译和汇编</td>
</tr>
<tr>
<td align="left">-v &#x2F; –version</td>
<td align="left">查看gcc版本号</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">包含调试信息</td>
</tr>
<tr>
<td align="left">-On n&#x3D;0~3</td>
<td align="left">编译优化，n越大优化得越多</td>
</tr>
<tr>
<td align="left">-Wall</td>
<td align="left">提示更多警告信息</td>
</tr>
<tr>
<td align="left">-D</td>
<td align="left">编译时定义宏</td>
</tr>
</tbody></table>
<h3 id="静态、动态链接"><a href="#静态、动态链接" class="headerlink" title="静态、动态链接"></a><strong>静态、动态链接</strong></h3><p>gcc -static test.c -o test</p>
<p><strong>静态库：</strong></p>
<p>ar -rcs libxxx.a x.o xx.o xxx.o</p>
<ul>
<li>r更新</li>
<li>c创建</li>
<li>s建立索引</li>
</ul>
<p>gcc test.c -L.&#x2F; -I.&#x2F; -lxxx -o test</p>
<ul>
<li>-L：表示要连接的库所在目录</li>
<li>-I.&#x2F;: I(大写i) 表示指定头文件的目录为当前目录</li>
<li>-l(小写L)：指定链接时需要的库，去掉前缀和后缀</li>
</ul>
<p><strong>动态库：</strong></p>
<p>-fPIC 编译生成与地址无关</p>
<p>gcc  -shared xxx.o xx.o x.o -o libxxx.so</p>
<p>查看库函数：nm libxxx.so</p>
<p>ldd 查看依赖</p>
<p>gcc test.c -L.&#x2F; -I.&#x2F; -lxxx -o test编译时需指定绝对路径</p>
<ol>
<li>拷贝到&#x2F;lib或&#x2F;usr&#x2F;lib</li>
<li>export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:PATH</li>
<li>echo &#x2F;home&#x2F;your_path &gt;&gt; ld.sp.conf &amp;&amp; ldconfig</li>
<li>ln -s &#x2F;home&#x2F;your_path&#x2F;libxxx.so &#x2F;lib&#x2F;libxxx.so</li>
</ol>
<h3 id="makefile："><a href="#makefile：" class="headerlink" title="makefile："></a>makefile：</h3><p><code>make [ -f file ][ options ][ targets ]</code></p>
<ul>
<li>-v： 显示make工具的版本信息</li>
<li>-w： 在处理makefile之前和之后显示工作路径</li>
<li>-C dir：读取makefile之前改变工作路径至dir目录</li>
<li>-n：只打印要执行的命令但不执行</li>
<li>-s：执行但不显示执行的命令</li>
</ul>
<p>原理：</p>
<p>分析目标和依赖关系；根据依赖自底向上执行；修改时间比目标新则更新；如不依赖任何条件则执行对应命令</p>
<p><strong>变量：</strong></p>
<blockquote>
<p>CC &#x3D; gcc #arm-linux-gcc</p>
<p>CPPFLAGS : C预处理的选项 如:-I</p>
<p>CFLAGS: C编译器的选项 -Wall -g -c</p>
<p>LDFLAGS : 链接器选项 -L -l</p>
</blockquote>
<blockquote>
<p>$@: 表示规则中的目标</p>
<p>$&lt;: 表示规则中的第一个条件</p>
<p>$^: 表示规则中的所有条件, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。</p>
<p>%：匹配一个模式规则</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OBJS=test.o add.o sub.o mul.o div.o</span><br><span class="line">TARGET=test</span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(OBJS)</span></span><br><span class="line">    gcc <span class="variable">$(OBJS)</span> -o <span class="variable">$(TARGET)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>函数：都有返回会值</p>
<blockquote>
<ol>
<li>wildcard – 查找指定目录下的指定类型的文件</li>
</ol>
<p>src &#x3D; $(wildcard *.c) &#x2F;&#x2F;找到当前目录下所有后缀为.c的文件,赋值给src</p>
<ol>
<li>patsubst – 匹配替换</li>
</ol>
<p>obj &#x3D; $(patsubst %.c,%.o, $(src)) &#x2F;&#x2F;把src变量里所有后缀为.c的文件替换成.o</p>
</blockquote>
<p>伪目标：</p>
<p>.PHONY:clean</p>
<ul>
<li>“-”此条命令出错，make也会继续执行后续的命令。如:“-rm main.o”</li>
<li>“@”不显示命令本身,只显示结果。如:“@echo clean done”</li>
</ul>
<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">├── inc</span><br><span class="line">│   ├── add.h</span><br><span class="line">│   ├── div.h</span><br><span class="line">│   ├── mul.h</span><br><span class="line">│   └── sub.h</span><br><span class="line">├── Makefile</span><br><span class="line">├── obj</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── mul.c</span><br><span class="line">    ├── sub.c</span><br><span class="line">    └── test.c</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Iinc</span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">wildcard</span> src/*.c)</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> src/%.c, obj/%.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">bin/test: <span class="variable">$(OBJS)</span></span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">obj/%.o: src/%.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> bin/test</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br></pre></td></tr></table></figure>





<h3 id="C库IO函数"><a href="#C库IO函数" class="headerlink" title="C库IO函数"></a>C库IO函数</h3><p><img src="file:///D:/study/cpp/heima32/%E7%AC%AC4%E9%98%B6%E6%AE%B5-Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC03%E5%A4%A9%EF%BC%88makefile-%E6%96%87%E4%BB%B6IO%EF%BC%89/1-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1527650554264.png" alt="1527650554264"></p>
<p><strong>错误号：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/include/asm-generic/errno-base.h</span><br><span class="line">/usr/include/asm-generic/errno.h</span><br></pre></td></tr></table></figure>

<h3 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a><strong>文件IO</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">    whence：其取值如下：</span><br><span class="line">        SEEK_SET：从文件开头移动offset个字节</span><br><span class="line">        SEEK_CUR：从当前位置移动offset个字节</span><br><span class="line">        SEEK_END：从文件末尾移动offset个字节</span><br></pre></td></tr></table></figure>

<h3 id="文件操作相关："><a href="#文件操作相关：" class="headerlink" title="文件操作相关："></a>文件操作相关：</h3><h4 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *path, struct stat *buf);</span><br><span class="line">int lstat(const char *pathname, struct stat *buf);</span><br><span class="line">功能：</span><br><span class="line">    获取文件状态信息</span><br><span class="line">    stat和lstat的区别：</span><br><span class="line">        当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；</span><br><span class="line">        而stat返回的是该链接指向的文件的信息。</span><br><span class="line">        </span><br><span class="line">struct stat &#123;</span><br><span class="line">    dev_t           st_dev;     //文件的设备编号</span><br><span class="line">    ino_t           st_ino;     //节点</span><br><span class="line">    mode_t          st_mode;            //文件的类型和存取的权限</span><br><span class="line">    nlink_t         st_nlink;       //连到该文件的硬连接数目，刚建立的文件值为1</span><br><span class="line">    uid_t           st_uid;     //用户ID</span><br><span class="line">    gid_t           st_gid;     //组ID</span><br><span class="line">    dev_t           st_rdev;        //(设备类型)若此文件为设备文件，则为其设备编号</span><br><span class="line">    off_t           st_size;        //文件字节数(文件大小)</span><br><span class="line">    blksize_t       st_blksize;     //块大小(文件系统的I/O 缓冲区大小)</span><br><span class="line">    blkcnt_t        st_blocks;      //块数</span><br><span class="line">    time_t          st_atime;       //最后一次访问时间</span><br><span class="line">    time_t          st_mtime;       //最后一次修改时间</span><br><span class="line">    time_t          st_ctime;       //最后一次改变时间(指属性)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S_ISREG()	010 普通文件</span><br><span class="line">S_ISDIR()	004 目录</span><br><span class="line">S_ISCHR()	002 字符设备</span><br><span class="line">S_ISBLK()	006 块设备</span><br><span class="line">S_ISFIFO()	001 管道</span><br><span class="line">S_ISLNK()	012 符号链接</span><br><span class="line">S_ISSOCK()	014 套接字</span><br></pre></td></tr></table></figure>

<h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">功能：测试指定文件是否具有某种属性</span><br><span class="line">参数：</span><br><span class="line">    pathname：文件名</span><br><span class="line">    mode：文件权限，4种权限</span><br><span class="line">        R_OK：   是否有读权限</span><br><span class="line">        W_OK：   是否有写权限</span><br><span class="line">        X_OK：   是否有执行权限</span><br><span class="line">        F_OK：   测试文件是否存在</span><br></pre></td></tr></table></figure>

<h4 id="修改文件权限函数"><a href="#修改文件权限函数" class="headerlink" title="修改文件权限函数"></a>修改文件权限函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int chmod(const char *pathname, mode_t mode);</span><br><span class="line">int chown(const char *pathname, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure>

<h4 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int truncate(const char *path, off_t length);</span><br><span class="line">功能：修改文件大小</span><br><span class="line">参数：</span><br><span class="line">    path：文件文件名字</span><br><span class="line">    length：指定的文件大小</span><br><span class="line">        a)比原来小, 删掉后边的部分</span><br><span class="line">        b)比原来大, 向后拓展</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="link函数"><a href="#link函数" class="headerlink" title="link函数"></a>link函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int link(const char *oldpath, const char *newpath);</span><br><span class="line">功能：创建一个硬链接</span><br><span class="line">参数：</span><br><span class="line">    oldpath：源文件名字</span><br><span class="line">    newpath：硬链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="symlink函数"><a href="#symlink函数" class="headerlink" title="symlink函数"></a>symlink函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int symlink(const char *target, const char *linkpath);</span><br><span class="line">功能：创建一个软链接</span><br><span class="line">参数：</span><br><span class="line">    target：源文件名字</span><br><span class="line">    linkpath：软链接名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="readlink函数"><a href="#readlink函数" class="headerlink" title="readlink函数"></a>readlink函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);</span><br><span class="line">功能：读软连接对应的文件名，不是读内容(该函数只能读软链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：软连接名</span><br><span class="line">    buf：存放软件对应的文件名</span><br><span class="line">    bufsiz ：缓冲区大小(第二个参数存放的最大字节数)</span><br><span class="line">返回值：</span><br><span class="line">    成功：&gt;0，读到buf中的字符个数</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="unlink函数"><a href="#unlink函数" class="headerlink" title="unlink函数"></a>unlink函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int unlink(const char *pathname);</span><br><span class="line">功能：删除一个文件(软硬链接文件)</span><br><span class="line">参数：</span><br><span class="line">    pathname：删除的文件名字</span><br><span class="line">返回值：</span><br><span class="line">    成功：0</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int rename(const char *oldpath, const char *newpath);</span><br><span class="line">功能：把oldpath的文件名改为newpath</span><br><span class="line">参数：</span><br><span class="line">oldpath：旧文件名</span><br><span class="line">newpath：新文件名</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：-1</span><br></pre></td></tr></table></figure>

<h4 id="fcnlt函数"><a href="#fcnlt函数" class="headerlink" title="fcnlt函数"></a>fcnlt函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int fcntl(int fd, int cmd, ... /* arg */);</span><br><span class="line">功能：改变已打开的文件性质，fcntl针对描述符提供控制。</span><br><span class="line">参数：</span><br><span class="line">    fd：操作的文件描述符</span><br><span class="line">    cmd：操作方式</span><br><span class="line">    arg：针对cmd的值，fcntl能够接受第三个参数int arg。</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回某个其他值</span><br><span class="line">    失败：-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fcntl函数有5种功能：</p>
<ol>
<li>复制一个现有的描述符（cmd&#x3D;F_DUPFD）</li>
<li>获得／设置文件描述符标记(cmd&#x3D;F_GETFD或F_SETFD)</li>
<li>获得／设置文件状态标记(cmd&#x3D;F_GETFL或F_SETFL)</li>
<li>获得／设置异步I&#x2F;O所有权(cmd&#x3D;F_GETOWN或F_SETOWN)</li>
<li>获得／设置记录锁(cmd&#x3D;F_GETLK, F_SETLK或F_SETLKW)</li>
</ol>
</blockquote>
<p>目录相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char *getcwd(char *buf, size_t size);</span><br><span class="line">int chdir(const char *path);</span><br><span class="line">DIR *opendir(const char *name);</span><br><span class="line">int closedir(DIR *dirp);</span><br><span class="line">struct dirent *readdir(DIR *dirp);</span><br><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    ino_t d_ino;                  // 此目录进入点的inode</span><br><span class="line">    off_t d_off;                    // 目录文件开头至此目录进入点的位移</span><br><span class="line">    signed short int d_reclen;      // d_name 的长度, 不包含NULL 字符</span><br><span class="line">    unsigned char d_type;           // d_type 所指的文件类型 </span><br><span class="line">    char d_name[256];               // 文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>取值</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">DT_BLK</td>
<td align="left">块设备</td>
</tr>
<tr>
<td align="left">DT_CHR</td>
<td align="left">字符设备</td>
</tr>
<tr>
<td align="left">DT_DIR</td>
<td align="left">目录</td>
</tr>
<tr>
<td align="left">DT_LNK</td>
<td align="left">软链接</td>
</tr>
<tr>
<td align="left">DT_FIFO</td>
<td align="left">管道</td>
</tr>
<tr>
<td align="left">DT_REG</td>
<td align="left">普通文件</td>
</tr>
<tr>
<td align="left">DT_SOCK</td>
<td align="left">套接字</td>
</tr>
<tr>
<td align="left">DT_UNKNOWN</td>
<td align="left">未知</td>
</tr>
</tbody></table>
<h3 id="时间相关函数"><a href="#时间相关函数" class="headerlink" title="时间相关函数"></a>时间相关函数</h3><p>utime</p>
<p>time</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>进程运行时，内核为进程每个进程分配一个PCB（进程控制块），维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。</p>
<p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看struct task_struct 结构体定义：</p>
<ul>
<li>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。</li>
<li>进程的状态，有就绪、运行、挂起、停止等状态。</li>
<li>进程切换时需要保存和恢复的一些CPU寄存器。</li>
<li>描述虚拟地址空间的信息。</li>
<li>描述控制终端的信息。</li>
<li>当前工作目录（Current Working Directory）。</li>
<li>umask掩码。</li>
<li>文件描述符表，包含很多指向file结构体的指针。</li>
<li>和信号相关的信息。</li>
<li>用户id和组id。</li>
<li>会话（Session）和进程组。</li>
<li>进程可以使用的资源上限（Resource Limit）。</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在三态模型中，进程状态分为三个基本状态，即<strong>运行态，就绪态，阻塞态</strong>。</p>
<p>在五态模型中，进程分为<strong>新建态、终止态，运行态，就绪态，阻塞态</strong>。</p>
<p><img src="file:///D:/study/cpp/heima32/%E7%AC%AC4%E9%98%B6%E6%AE%B5-Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC05%E5%A4%A9%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%89/1-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1527908066890.png" alt="1527908066890"></p>
<p>​	<strong>①TASK_RUNNING：</strong>进程正在被CPU执行。当一个进程刚被创建时会处于TASK_RUNNABLE，表示己经准备就绪，正等待被调度。</p>
<p>　　<strong>②TASK_INTERRUPTIBLE（可中断）：</strong>进程正在睡眠（也就是说它被阻塞）等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于<strong>此状态的进程也会因为接收到信号而提前被唤醒</strong>，<strong>比如给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNABLE状态），然后再响应SIGKILL信号而退出</strong>（变为TASK_ZOMBIE状态），并不会从TASK_INTERRUPTIBLE状态直接退出。</p>
<p>　　<strong>③TASK_UNINTERRUPTIBLE（不可中断）：</strong>处于等待中的进程，待资源满足时被唤醒，<strong>但不可以由其它进程通过信号或中断唤醒</strong>。由于不接受外来的任何信号，<strong>因此无法用kill杀掉这些处于该状态的进程</strong>。而<strong>TASK_UNINTERRUPTIBLE状态存在的意义就在于</strong>，<strong>内核的某些处理流程是不能被打断的</strong>。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程，于是原有的流程就被中断了，这可能使某些设备陷入不可控的状态。处于TASK_UNINTERRUPTIBLE状态一般总是非常短暂的，通过ps命令基本上不可能捕捉到。</p>
<p>　　<strong>④TASK_ZOMBIE（僵死）：</strong>表示进程已经结束了，<strong>但是其父进程还没有调用wait4或waitpid()来释放进程描述符</strong>。为了父进程能够获知它的消息，子进程的进程描述符仍然被保留着。一旦父进程调用了wait4()，进程描述符就会被释放。</p>
<p>　　<strong>⑤TASK_STOPPED（停止）：</strong>进程停止执行。当进程接收到SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU等信号的时候。此外，<strong>在调试期间接收到任何信号</strong>，都会使进程进入这种状态。<strong>当接收到SIGCONT信号，会重新回到TASK_RUNNABLE</strong>。</p>
<p>stat中的参数意义如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>参数</strong></th>
<th align="left"><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">D</td>
<td align="left">不可中断 Uninterruptible（usually IO）</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">正在运行，或在队列中的进程</td>
</tr>
<tr>
<td align="left">S(大写)</td>
<td align="left">处于休眠状态</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">停止或被追踪</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">僵尸进程</td>
</tr>
<tr>
<td align="left">W</td>
<td align="left">进入内存交换（从内核2.6开始无效）</td>
</tr>
<tr>
<td align="left">X</td>
<td align="left">死掉的进程</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">高优先级</td>
</tr>
<tr>
<td align="left">N</td>
<td align="left">低优先级</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">包含子进程</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">位于前台的进程组</td>
</tr>
</tbody></table>
<p>ps查看进程详细状态</p>
<p>top命令用来动态显示运行中的进程</p>
<p>kill [-signal] pid；一般信号9，SIGTERM</p>
<p>killall通过进程名字杀死进程</p>
<h3 id="进程相关函数"><a href="#进程相关函数" class="headerlink" title="进程相关函数"></a>进程相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid, ppid, pgid;</span><br><span class="line">    pid = getpid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid = %d\n&quot;</span>, pid);</span><br><span class="line">    ppid = getppid();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ppid = %d\n&quot;</span>, ppid);</span><br><span class="line">    pgid = getpgid(pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pgid = %d\n&quot;</span>, pgid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line">    options : options 提供了一些额外的选项来控制 waitpid()。</span><br><span class="line">            <span class="number">0</span>：同 wait()，阻塞父进程，等待子进程退出。</span><br><span class="line">            WNOHANG：没有任何已经结束的子进程，则立即返回。</span><br><span class="line">            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）</span><br></pre></td></tr></table></figure>

<p>Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。共享同一个地址空间</p>
<p>fork()函数继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等，代价巨大</p>
<p>fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p>
<p>父子进程各自的地址空间是独立的</p>
<p><strong>gdb调试多进程</strong></p>
<p>使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。</p>
<ul>
<li>set follow-fork-mode child 设置gdb在fork之后跟踪子进程。</li>
<li>set follow-fork-mode parent 设置跟踪父进程（默认）。</li>
</ul>
<p>注意，一定要在fork函数调用之前设置才有效。</p>
<p>_exit直接调用 _exit系统调用，exit()是标准库函数，先atexit注册退出处理函数，然后刷新IO缓存，关文件描述符，再调用 _ exit</p>
<p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</p>
<p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
<h3 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h3><p>exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>; <span class="comment">//系统调用</span></span><br></pre></td></tr></table></figure>



<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="无名管道："><a href="#无名管道：" class="headerlink" title="无名管道："></a><strong>无名管道：</strong></h4><p>管道中有数据，read返回实际读到的字节数。</p>
<p>管道中无数据：</p>
<p>管道写端被全部关闭，read返回0 (相当于读到文件结尾)</p>
<p>写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)</p>
<p>管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程终止)</p>
<p>管道读端没有全部关闭：</p>
<p>管道已满，write阻塞。</p>
<p>管道未满，write将数据写入，并返回实际写入的字节数。</p>
<p>可以使用ulimit -a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">    fd：文件描述符</span><br><span class="line">    name：</span><br><span class="line">        _PC_PIPE_BUF，查看管道缓冲区大小</span><br><span class="line">        _PC_NAME_MAX，文件名字字节数的上限</span><br></pre></td></tr></table></figure>

<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a><strong>有名管道</strong></h4><p>以 FIFO 的文件形式存在于文件系统中，这样，即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
<p><strong>特点</strong></p>
<ol>
<li>FIFO 在文件系统中作为一个特殊的文件而存在，但 FIFO 中的内容却存放在<strong>内存</strong>中。</li>
<li>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</li>
<li>FIFO 有名字，不相关的进程可以通过打开命名管道进行通信。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfifo &lt;name&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="共享存储映射"><a href="#共享存储映射" class="headerlink" title="共享存储映射"></a>共享存储映射</h4><p>存储映射I&#x2F;O (Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">参数：</span><br><span class="line">    addr :  指定映射的起始地址, 通常设为<span class="literal">NULL</span>, 由系统指定</span><br><span class="line">    length：映射到内存的文件长度</span><br><span class="line">    prot：  映射区的保护方式, 最常用的 :</span><br><span class="line">        a) 读：PROT_READ</span><br><span class="line">        b) 写：PROT_WRITE</span><br><span class="line">        c) 读写：PROT_READ | PROT_WRITE</span><br><span class="line">    flags：  映射区的特性, 可以是</span><br><span class="line">        a) MAP_SHARED : 写入映射区的数据会复制回文件, 且允许其他映射该文件的进程共享。</span><br><span class="line">        b) MAP_PRIVATE : 对映射区的写入操作会产生一个映射区的复制(copy - on - write), 对此区域所做的修改不会写回原文件。</span><br><span class="line">    fd：由open返回的文件描述符, 代表要映射的文件。</span><br><span class="line">    offset：以文件开始处的偏移量, 必须是<span class="number">4</span>k的整数倍, 通常为<span class="number">0</span>, 表示从文件头开始映射</span><br><span class="line">返回值：</span><br><span class="line">    成功：返回创建的映射区首地址</span><br><span class="line">    失败：MAP_FAILED宏</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>当MAP_SHARED时，要求：映射区的权限应 &lt;&#x3D;文件打开的权限(出于对映射区的保护)</p>
<p>当映射文件大小为0时，不能创建映射区。</p>
<p>文件偏移量必须为4K的整数倍</p>
<p>**MAP_ANONYMOUS (或MAP_ANON)**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int len = 1&lt;&lt;12;</span><br><span class="line">void* ptr = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span><br><span class="line">if(ptr == MAP_FAILED)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;mmap error&quot;);</span><br><span class="line">	exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid_t pid = fork();</span><br><span class="line">if(pid &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">	strcpy((char*)ptr, &quot;hello world!&quot;);</span><br><span class="line">	wait(NULL);</span><br><span class="line">&#125;</span><br><span class="line">else if(pid == 0)</span><br><span class="line">&#123;</span><br><span class="line">	sleep(1);</span><br><span class="line">	printf(&quot;%s\n&quot;, (char*)ptr);</span><br><span class="line">&#125;</span><br><span class="line">int ret = munmap(ptr, len);</span><br><span class="line">if(ret == -1)</span><br><span class="line">&#123;</span><br><span class="line">	perror(&quot;munmap error&quot;);</span><br><span class="line">	eixt(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式 </p>
<p><strong>信号的特点</strong></p>
<ul>
<li>简单</li>
<li>不能携带大量信息</li>
<li>满足某个特设条件才发送</li>
</ul>
<p> 一个完整的信号周期包括三个部分：信号的产生，信号在进程中的注册，信号在进程中的注销，执行信号处理函数</p>
<p><code>kill -l</code>常规信号</p>
<table>
<thead>
<tr>
<th align="left"><strong>编号</strong></th>
<th align="left"><strong>信号</strong></th>
<th align="left"><strong>对应事件</strong></th>
<th align="left"><strong>默认动作</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">SIGHUP</td>
<td align="left">用户退出shell时，由该shell启动的所有进程将收到这个信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>SIGINT</strong></td>
<td align="left">当用户按下了**&lt;Ctrl+C&gt;**组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>SIGQUIT</strong></td>
<td align="left">用户按下**&lt;ctrl+\ &gt;**组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SIGILL</td>
<td align="left">CPU检测到某进程执行了非法指令</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SIGTRAP</td>
<td align="left">该信号由断点指令或其他 trap指令产生</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SIGABRT</td>
<td align="left">调用abort函数时产生该信号</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">SIGBUS</td>
<td align="left">非法访问内存地址，包括内存对齐出错</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">SIGFPE</td>
<td align="left">在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">SIGKILL</td>
<td align="left">无条件终止进程。本信号不能被忽略，处理和阻塞</td>
<td align="left">终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SIGUSE1</td>
<td align="left">用户定义的信号。即程序员可以在程序中定义并使用该信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>SIGSEGV</strong></td>
<td align="left">指示进程进行了无效内存访问(段错误)</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">SIGUSR2</td>
<td align="left">另外一个用户自定义信号，程序员可以在程序中定义并使用该信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>SIGPIPE</strong></td>
<td align="left">Broken pipe向一个没有读端的管道写数据</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">SIGALRM</td>
<td align="left">定时器超时，超时的时间 由系统调用alarm设置</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">SIGTERM</td>
<td align="left">程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">SIGSTKFLT</td>
<td align="left">Linux早期版本出现的信号，现仍保留向后兼容</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>SIGCHLD</strong></td>
<td align="left">子进程结束时，父进程会收到这个信号</td>
<td align="left">忽略这个信号</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">SIGCONT</td>
<td align="left">如果进程已停止，则使其继续运行</td>
<td align="left">继续&#x2F;忽略</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">SIGSTOP</td>
<td align="left">停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td align="left">为终止进程</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">SIGTSTP</td>
<td align="left">停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">SIGTTIN</td>
<td align="left">后台进程读终端控制台</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">SIGTTOU</td>
<td align="left">该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生</td>
<td align="left">暂停进程</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">SIGURG</td>
<td align="left">套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">SIGXCPU</td>
<td align="left">进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">SIGXFSZ</td>
<td align="left">超过文件的最大长度设置</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">SIGVTALRM</td>
<td align="left">虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">SGIPROF</td>
<td align="left">类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">SIGWINCH</td>
<td align="left">窗口变化大小时发出</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">SIGIO</td>
<td align="left">此信号向进程指示发出了一个异步IO事件</td>
<td align="left">忽略该信号</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">SIGPWR</td>
<td align="left">关机</td>
<td align="left">终止进程</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">SIGSYS</td>
<td align="left">无效的系统调用</td>
<td align="left">终止进程并产生core文件</td>
</tr>
<tr>
<td align="left">34~64</td>
<td align="left">SIGRTMIN ～ SIGRTMAX</td>
<td align="left">LINUX的实时信号，它们没有固定的含义（可以由用户自定义）</td>
<td align="left">终止进程</td>
</tr>
</tbody></table>
<p>每个信号必备4要素，分别是：</p>
<p>1）编号 2）名称 3）事件 4）默认处理动作</p>
<p>可通过<strong>man 7 signal</strong>查看帮助文档获取：</p>
<p>标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。</p>
<blockquote>
<p>The signals <strong>SIGKILL</strong> and <strong>SIGSTOP</strong> cannot be caught, blocked, or ignored.</p>
</blockquote>
<h3 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line">功能：给指定进程发送指定信号(不一定杀死)</span><br><span class="line">参数：</span><br><span class="line">    pid : 取值有 <span class="number">4</span> 种情况 :</span><br><span class="line">        pid &gt; <span class="number">0</span>:  将信号传送给进程 ID 为pid的进程。</span><br><span class="line">        pid = <span class="number">0</span> :  将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">        pid = <span class="number">-1</span> : 将信号传送给系统内所有的进程。</span><br><span class="line">        pid &lt; <span class="number">-1</span> : 将信号传给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int raise(int sig);</span><br><span class="line">功能：给当前进程发送指定信号(自己给自己发)，等价于 kill(getpid(), sig)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void abort(void);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。</span><br><span class="line">    取消定时器alarm(0)，返回旧闹钟余下秒数。</span><br></pre></td></tr></table></figure>

<p>定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">​</span><br><span class="line">int setitimer(int which,  const struct itimerval *new_value, struct itimerval *old_value);</span><br><span class="line">功能：</span><br><span class="line">    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。</span><br><span class="line">参数：</span><br><span class="line">    which：指定定时方式</span><br><span class="line">        a) 自然定时：ITIMER_REAL → 14）SIGALRM计算自然时间</span><br><span class="line">        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL → 26）SIGVTALRM  只计算进程占用cpu的时间</span><br><span class="line">        c) 运行时计时(用户 + 内核)：ITIMER_PROF → 27）SIGPROF计算占用cpu及执行系统调用的时间</span><br><span class="line">    new_value：struct itimerval, 负责设定timeout时间</span><br><span class="line">        struct itimerval &#123;</span><br><span class="line">            struct timerval it_interval; // 闹钟触发周期</span><br><span class="line">            struct timerval it_value;    // 闹钟触发时间</span><br><span class="line">        &#125;;</span><br><span class="line">        struct timeval &#123;</span><br><span class="line">            long tv_sec;            // 秒</span><br><span class="line">            long tv_usec;           // 微秒</span><br><span class="line">        &#125;</span><br><span class="line">        itimerval.it_value： 设定第一次执行function所延迟的秒数 </span><br><span class="line">        itimerval.it_interval：  设定以后每几秒执行function</span><br><span class="line">​</span><br><span class="line">    old_value： 存放旧的timeout值，一般指定为NULL</span><br></pre></td></tr></table></figure>

<h3 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>未决状态：没有被处理</strong></p>
<p><strong>递达状态：信号被处理了</strong></p>
<p>Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指<strong>阻塞信号集和未决信号集</strong>。</p>
<p><strong>阻塞信号集(信号屏蔽字)</strong></p>
<p>将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(处理发生在解除屏蔽后)。</p>
<p><strong>未决信号集</strong></p>
<p>信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。</p>
<p>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。</p>
<hr>
<p>这两个信号集都是内核使用<strong>位图机制</strong>来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。</p>
<h4 id="自定义信号集函数"><a href="#自定义信号集函数" class="headerlink" title="自定义信号集函数"></a>自定义信号集函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;       <span class="comment">//将set集合置空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>；          <span class="comment">//将所有信号加入set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;  <span class="comment">//将signo信号加入到set集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>;   <span class="comment">//从set集合中移除signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signo)</span>; <span class="comment">//判断信号是否存在</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    ret = isgismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is not a member of set \nret = %d\n&quot;</span>, ret);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is a member of set \nret = %d\n&quot;</span>, ret);</span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT is not a member of set \nret = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="阻塞信号集"><a href="#阻塞信号集" class="headerlink" title="阻塞信号集"></a>阻塞信号集</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line">功能：</span><br><span class="line">    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 <span class="built_in">set</span> 指定，而原先的信号阻塞集合由 oldset 保存。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">    how : 信号阻塞集合的修改方法，有 <span class="number">3</span> 种情况：</span><br><span class="line">        SIG_BLOCK：向信号阻塞集合中添加 <span class="built_in">set</span> 信号集，新的信号掩码是<span class="built_in">set</span>和旧信号掩码的并集。相当于 mask = mask|<span class="built_in">set</span>。</span><br><span class="line">        SIG_UNBLOCK：从信号阻塞集合中删除 <span class="built_in">set</span> 信号集，从当前信号掩码中去除 <span class="built_in">set</span> 中的信号。相当于 mask = mask &amp; ~ <span class="built_in">set</span>。</span><br><span class="line">        SIG_SETMASK：将信号阻塞集合设为 <span class="built_in">set</span> 信号集，相当于原来信号阻塞集的内容清空，然后按照 <span class="built_in">set</span> 中的信号重新设置信号阻塞集。相当于mask = <span class="built_in">set</span>。</span><br><span class="line">    <span class="built_in">set</span> : 要操作的信号集地址。</span><br><span class="line">        若 <span class="built_in">set</span> 为 <span class="literal">NULL</span>，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。</span><br><span class="line">    oldset : 保存原先信号阻塞集地址</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sigpending(<span class="type">sigset_t</span> *<span class="built_in">set</span>);</span><br><span class="line">功能：读取当前进程的未决信号集</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">itn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> myset, old;</span><br><span class="line">    sigemptyset(&amp;myset);</span><br><span class="line">    sigaddset(&amp;myset, SIGINT);</span><br><span class="line">    sigaddset(&amp;myset, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;myset, SIGKILL);</span><br><span class="line">    sigprocmask(SIG-BLOCK, &amp;myset, &amp;old);</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> pend;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sigismember(&amp;pend, i)) <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sigismember(&amp;pend, i) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;old, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><p>SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。</p>
<p><strong>内核实现信号捕捉过程：</strong></p>
<p><img src="file:///D:/study/cpp/heima32/%E7%AC%AC4%E9%98%B6%E6%AE%B5-Linux%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%AC%AC07%E5%A4%A9%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/1-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/assets/1527931072795.png" alt="1527931072795"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>(*sa_handler)(<span class="type">int</span>); <span class="comment">//旧的信号处理函数指针</span></span><br><span class="line">    <span class="type">void</span>(*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">//新的信号处理函数指针</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;      <span class="comment">//信号阻塞集</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;     <span class="comment">//信号处理的方式</span></span><br><span class="line">    <span class="type">void</span>(*sa_restorer)(<span class="type">void</span>); <span class="comment">//已弃用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line">     <span class="class"><span class="keyword">union</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span>   sival_int;</span><br><span class="line">        <span class="type">void</span> *sival_ptr;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SIGCHLD信号避免僵尸进程"><a href="#SIGCHLD信号避免僵尸进程" class="headerlink" title="SIGCHLD信号避免僵尸进程"></a>SIGCHLD信号避免僵尸进程</h3><ol>
<li>子进程终止时</li>
<li>子进程接收到SIGSTOP信号停止时</li>
<li>子进程处在停止态，接受到SIGCONT后唤醒时</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error:&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid id %d.I am exiting.\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am father, i am exited\n\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;ps -ef | grep defunct&quot;</span>); <span class="comment">// 查看有没有僵尸进程    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用dup和exce实现：ps aux|grep bash</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">01</span>;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    ret = pipe(fd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err0;</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        dup2(fd[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">        execlp(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;grep&quot;</span>, <span class="string">&quot;bash&quot;</span>,<span class="string">&quot;--color=auto&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err0:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* time_t rawtime;</span></span><br><span class="line"><span class="comment">* time ( &amp;rawtime  ); --- 获取时间，以秒计，从1970年1月一日起算，存于rawtime</span></span><br><span class="line"><span class="comment">* localtime ( &amp;rawtime  ); //转为当地时间，tm 时间结构</span></span><br><span class="line"><span class="comment">* asctime() // 转为标准ASCII时间格式：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_time</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> rawtime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> * <span class="title">timeinfo</span>;</span></span><br><span class="line">    <span class="comment">// 获取时间</span></span><br><span class="line">    time(&amp;rawtime);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 转为本地时间</span></span><br><span class="line">    timeinfo = localtime(&amp;rawtime);</span><br><span class="line">    <span class="comment">// 转为标准ASCII时间格式</span></span><br><span class="line">    <span class="type">char</span> *cur = asctime(timeinfo);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span>* cur = ctime(&amp;rawtime);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将得到的时间写入文件中</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/home/edu/timelog.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    <span class="type">int</span> ret = write(fd, cur, <span class="built_in">strlen</span>(cur) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 父进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 提升为会长，同时也是新进程组的组长</span></span><br><span class="line">        setsid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改进程的执行目录</span></span><br><span class="line">        chdir(<span class="string">&quot;/home/edu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改掩码</span></span><br><span class="line">        umask(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件描述符</span></span><br><span class="line">        close(STDIN_FILENO);</span><br><span class="line">        close(STDOUT_FILENO);</span><br><span class="line">        close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册信号捕捉函数</span></span><br><span class="line">        <span class="comment">//先注册，再定时</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigact</span>;</span></span><br><span class="line">        sigact.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;sigact.sa_mask);</span><br><span class="line">        sigact.sa_handler = write_time;</span><br><span class="line">        sigaction(SIGALRM, &amp;sigact, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置定时器</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">act</span>;</span></span><br><span class="line">        <span class="comment">// 定时周期</span></span><br><span class="line">        act.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">        act.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置第一次触发定时器时间</span></span><br><span class="line">        act.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">        act.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始计时</span></span><br><span class="line">        setitimer(ITIMER_REAL, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止子进程退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程号只在它所属的进程环境中有效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">            <span class="type">void</span> *arg )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>

<p>线程的取消并不是实时的，而又一定的延时。需要等待线程到达某个取消点(检查点)。</p>
<p>杀死线程也不是立刻就能完成，必须要到达取消点。</p>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write….. 执行命令<strong>man 7 pthreads</strong>可以查看具备这些取消点的系统调用列表。</p>
<p><strong>线程属性</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>             etachstate;     <span class="comment">//线程的分离状态</span></span><br><span class="line">    <span class="type">int</span>             schedpolicy;    <span class="comment">//线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>  <span class="title">schedparam</span>;</span> <span class="comment">//线程的调度参数</span></span><br><span class="line">    <span class="type">int</span>             inheritsched;   <span class="comment">//线程的继承性</span></span><br><span class="line">    <span class="type">int</span>             scope;      <span class="comment">//线程的作用域</span></span><br><span class="line">    <span class="type">size_t</span>          guardsize;  <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">    <span class="type">int</span>             stackaddr_set; <span class="comment">//线程的栈设置</span></span><br><span class="line">    <span class="type">void</span>*           stackaddr;  <span class="comment">//线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span>          stacksize;  <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="type">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br><span class="line">    attr：已初始化的线程属性</span><br><span class="line">    detachstate：    分离状态</span><br><span class="line">        PTHREAD_CREATE_DETACHED（分离线程）</span><br><span class="line">        PTHREAD_CREATE_JOINABLE（非分离线程）</span><br></pre></td></tr></table></figure>

<p>这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。</p>
<p>要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。</p>
<p>设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 0x100000</span></span><br><span class="line"><span class="type">void</span>*<span class="title function_">th_func</span><span class="params">(<span class="type">void</span>*arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> err. detachstate, i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">size_t</span> stacksize;</span><br><span class="line">    <span class="type">void</span> *stackaddr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_getstack(&amp;attr, &amp;stackaddr, &amp;stacksize);</span><br><span class="line">    pthread_attr_getdetachstate(&amp;attr, &amp;detachstate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(detachstate == PTHREAD_CREATE_DETACHED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread is detached\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(detachstate == PTHREAD_CREATE_JOINABLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread is joinable\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread is unknow\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stackaddr = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">        <span class="keyword">if</span>(stackaddr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stacksize = SIZE;</span><br><span class="line">        pthread_attr_setstack(&amp;attr, stackaddr, stacksize);</span><br><span class="line">        err = pthread_create(&amp;tid, &amp;attr, th_func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err!= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create thread failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;create thread %d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line">参数：</span><br><span class="line">    mutex：互斥锁地址。类型是 <span class="type">pthread_mutex_t</span> 。</span><br><span class="line">    attr：设置互斥量的属性，通常可采用默认属性，即可将 attr 设为 <span class="literal">NULL</span>。</span><br><span class="line">    可以使用宏 PTHREAD_MUTEX_INITIALIZER 静态初始化互斥锁，比如：</span><br><span class="line">    <span class="type">pthread_mutex_t</span>  mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">这种方法等价于使用 <span class="literal">NULL</span> 指定的 attr 参数调用 pthread_mutex_init() 来完成动态初始化，不同之处在于 PTHREAD_MUTEX_INITIALIZER 宏不进行错误检查。</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>死锁引起的原因</strong></p>
<ul>
<li>竞争不可抢占资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<p><strong>预防死锁的方法</strong></p>
<p>*<strong>破坏请求和保持条件*</strong></p>
<p>协议1：</p>
<p>所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。</p>
<p>协议2：</p>
<p>允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。</p>
<p>*<strong>破坏不可抢占条件*</strong></p>
<p>当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请。</p>
<p>*<strong>破坏循环等待条件*</strong></p>
<p>对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">功能：</span><br><span class="line">    以阻塞方式在读写锁上获取读锁（读锁定）。</span><br><span class="line">    如果没有写者持有该锁，并且没有写者阻塞在该锁上，则调用线程会获取读锁。</span><br><span class="line">    如果调用线程未获取读锁，则它将阻塞直到它获取了该锁。一个线程可以在一个读写锁上多次执行读锁定。</span><br><span class="line">    线程可以成功调用 pthread_rwlock_rdlock() 函数 n 次，但是之后该线程必须调用 pthread_rwlock_unlock() 函数 n 次才能解除锁定。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line">   用于尝试以非阻塞的方式来在读写锁上获取读锁。</span><br><span class="line">   如果有任何的写者持有该锁或有写者阻塞在该读写锁上，则立即失败返回。</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read num first==%d\n&quot;</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read num second==%d\n&quot;</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func3</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write num first==%d\n&quot;</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">func4</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write num second==%d\n&quot;</span>, num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> rd1, rd2, wr1, wr2;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;rd1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;rd2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;wr1, <span class="literal">NULL</span>, func3, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;wr2, <span class="literal">NULL</span>, func4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(rd1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(rd2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(wr1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(wr2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>a) 阻塞等待条件变量cond（参1）满足</p>
<p>b) 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);<br>            a) b) 两步为一个原子操作。</p>
<pre><code>c) 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);
</code></pre>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>生产者消费者模型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">Node *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *new_node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        new_node-&gt;val = rand() % <span class="number">1000</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        new_node-&gt;next = head;</span><br><span class="line">        head = new_node;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======produce: %lu, %d\n&quot;</span>, pthread_self(), new_node-&gt;val);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line">        Node *tmp = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------consume: %lu, %d\n&quot;</span>, pthread_self(), tmp-&gt;val);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    srand((<span class="type">unsigned</span> <span class="type">long</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;lock);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于mutex而言，条件变量可以减少竞争。</p>
<p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的。</p>
<p>有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line">    pshared：等于 <span class="number">0</span>，信号量在线程间共享（常用）；不等于<span class="number">0</span>，信号量在进程间共享。</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>P操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>V操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>

<p>哲学家就餐问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">dinner</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="type">int</span> left = i;</span><br><span class="line">    <span class="type">int</span> right = (i + <span class="number">1</span>) % <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex[left]);</span><br><span class="line">        <span class="keyword">if</span>(pthread_mutex_trylock(&amp;mutex[right]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c is eating\n&quot;</span> , i+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex[left]);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex[right]);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_init(&amp;mutex[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid[i], <span class="literal">NULL</span>, dinner, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;mutex[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#96;&#96;</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Jerold</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/c/c++/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">http://example.com/c/c++/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Jerold‘s PNote</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a></div><div class="post-share"><div class="social-share" data-image="/img/covers/6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE/co-net/" title="co-net"><img class="cover" src="/img/covers/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">co-net</div></div><div class="info-2"><div class="info-item-1">LOG级别12345678910111213typedefenum &#123;     EMERG  = 0,     FATAL  = 0,     ALERT  = 100,     CRIT   = 200,     ERROR  = 300,     WARN   = 400,     NOTICE = 500,     INFO   = 600,     DEBUG  = 700,     NOTSET = 800 &#125;PriorityLevel;  Pattern 12345678910111213void log4cpp::PatternLayout::setConversionPattern  (conststd::string&amp;  conversionPattern)  throw(ConfigureFailure) [virtual]/*其中参数类型为std::string，类似于C语言中的printf，使用格式化字符串来描述输出格式，其具体含义如下：*  u %c category；*  u %d...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE/mprpc/" title="基于protobuf和muduo的RPC框架学习"><img class="cover" src="/img/covers/16.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">基于protobuf和muduo的RPC框架学习</div></div><div class="info-2"><div class="info-item-1">RPC原理即RPC字面意思，远程过程调用，跨机器调用方法，实际它的作用更大，常常用于网络通信中，例如分布式缓存，数据库等 网络通信以二进制传输数据，而protobuf序列化刚好生成二进制，既节约了空间，又实现网络通信条件， 与序列化协议的效率、性能、序列化协议后的体积相比，其通用性和兼容性的优先级会更高，因为他是会直接关系到服务调用的稳定性和可用率的 rpc一般用于高并发的场景，所以常结合IO多路复合，React模型来使用 零拷贝技术：sendifle，共享内存 simple mprpc记录应用mprpc框架的一个聊天室实现   mprpc protobuf使用：protc xxx.proto –cpp_out&#x3D;.&#x2F;  所有的message都有一个父类Message因此才有所有的service都有一个父类Service  一个login rpc12345678910111213141516171819202122232425262728syntax = &quot;proto3&quot;;package fixbug;option...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E5%B8%B8%E8%A7%81%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">linux常见目录：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">快捷键：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">gcc常用选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">静态、动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#makefile%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">makefile：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%BA%93IO%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">C库IO函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6IO"><span class="toc-number">8.</span> <span class="toc-text">文件IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">文件操作相关：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stat"><span class="toc-number">9.1.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access"><span class="toc-number">9.2.</span> <span class="toc-text">access</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">修改文件权限函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#truncate%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">truncate函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">link函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symlink%E5%87%BD%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">symlink函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readlink%E5%87%BD%E6%95%B0"><span class="toc-number">9.7.</span> <span class="toc-text">readlink函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlink%E5%87%BD%E6%95%B0"><span class="toc-number">9.8.</span> <span class="toc-text">unlink函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rename%E5%87%BD%E6%95%B0"><span class="toc-number">9.9.</span> <span class="toc-text">rename函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fcnlt%E5%87%BD%E6%95%B0"><span class="toc-number">9.10.</span> <span class="toc-text">fcnlt函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">时间相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB"><span class="toc-number">11.</span> <span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">12.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">进程相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">14.</span> <span class="toc-text">exec函数族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">15.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%9A"><span class="toc-number">15.1.</span> <span class="toc-text">无名管道：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">15.2.</span> <span class="toc-text">有名管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="toc-number">15.3.</span> <span class="toc-text">共享存储映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">16.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">信号相关函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">18.</span> <span class="toc-text">信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">18.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">18.2.</span> <span class="toc-text">自定义信号集函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">18.3.</span> <span class="toc-text">阻塞信号集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">19.</span> <span class="toc-text">信号捕捉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">SIGCHLD信号避免僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">23.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">24.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">25.</span> <span class="toc-text">条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">26.</span> <span class="toc-text">信号量</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Jerold</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>